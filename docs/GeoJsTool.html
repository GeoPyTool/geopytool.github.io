<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJsTool åœ°çƒåŒ–å­¦åˆ†æå·¥å…· - ç½‘é¡µç‰ˆ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; padding: 20px; color: #333;
        }
        .container { 
            max-width: 1200px; margin: 0 auto; 
            background: rgba(255,255,255,0.95); 
            border-radius: 15px; padding: 30px; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        h1 { 
            text-align: center; color: #4a5568; margin-bottom: 30px; 
            font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        .section { 
            margin-bottom: 25px; background: #f8f9fa; 
            padding: 20px; border-radius: 10px; border-left: 4px solid #4facfe;
        }
        .section h3 { color: #2d3748; margin-bottom: 15px; }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: 500; color: #4a5568; }
        input[type="file"], select { 
            width: 100%; padding: 10px; border: 2px solid #e2e8f0; 
            border-radius: 8px; font-size: 14px; transition: border-color 0.3s;
        }
        input[type="file"]:focus, select:focus { 
            outline: none; border-color: #4facfe; 
        }
        button { 
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); 
            color: white; border: none; padding: 12px 25px; 
            border-radius: 8px; cursor: pointer; font-size: 14px; 
            font-weight: 500; transition: all 0.3s;
        }
        button:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
        }
        button:disabled { 
            background: #cbd5e0; cursor: not-allowed; transform: none; 
        }
        
        /* Download buttons styling */
        #downloadButtons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 15px;
        }
        
        #downloadButtons button {
            min-width: 120px;
            font-size: 12px;
            padding: 10px 20px;
        }
        
        #downloadButtons button:nth-child(1) {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        #downloadButtons button:nth-child(2) {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #downloadButtons button:nth-child(3) {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
        }
        .plot-container { 
            margin-top: 20px; background: white; 
            padding: 20px; border-radius: 10px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: auto;
            max-width: 100%;
            max-height: 80vh;
        }
        
        #plotDiv {
            min-width: 800px;
            min-height: 600px;
            overflow: visible;
        }
        .data-preview { 
            max-height: 400px; 
            overflow: scroll; 
            margin-top: 15px; 
            background: white;
            width: 100%;
            max-width: 100%;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            /* Ensure both scroll bars are always visible */
            scrollbar-gutter: stable;
        }
        table { 
            width: auto !important;
            min-width: 100%;
            border-collapse: collapse; 
            font-size: 11px;
            table-layout: auto;
            /* Add margin to prevent scroll bar overlap */
            margin-bottom: 20px;
            margin-right: 20px;
        }
        th, td { 
            padding: 6px 8px;
            text-align: left; 
            border-bottom: 1px solid #e2e8f0; 
            white-space: nowrap;
            min-width: 80px;
            overflow: visible;
            text-overflow: ellipsis;
            vertical-align: middle;
        }
        th { 
            background: #f7fafc; 
            font-weight: 600; 
            position: sticky; 
            top: 0; 
            z-index: 10;
            font-size: 10px;
        }
        .section {
            overflow-x: hidden;
        }
        .options { display: none; }
        .alert { 
            padding: 15px; margin: 10px 0; border-radius: 8px; 
            font-weight: 500; border-left: 4px solid;
        }
        .alert-success { 
            background: #f0fff4; color: #22543d; border-color: #38a169; 
        }
        .alert-error { 
            background: #fed7d7; color: #742a2a; border-color: #e53e3e; 
        }
        .grid-container { 
            display: grid; grid-template-columns: 1fr 1fr; 
            gap: 20px; align-items: start;
        }
        @media (max-width: 768px) { 
            .grid-container { grid-template-columns: 1fr; }
            .container { padding: 15px; }
            th, td {
                padding: 4px 6px;
                font-size: 10px;
                max-width: 80px;
            }
            .data-preview {
                max-height: 200px;
            }
        }
        
        /* Ensure container doesn't overflow */
        .container, .section, .form-group {
            box-sizing: border-box;
            overflow-x: hidden;
        }
        
        /* Responsive table wrapper */
        .table-wrapper {
            overflow: scroll;
            width: 100%;
            max-width: 100%;
            /* Reserve space for scroll bars to prevent overlap */
            padding-right: 0;
            padding-bottom: 0;
            /* Ensure scroll bars don't overlap content */
            scrollbar-gutter: stable both-edges;
        }
        
        /* Custom scroll bar styling to ensure visibility */
        .data-preview::-webkit-scrollbar,
        .table-wrapper::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        .data-preview::-webkit-scrollbar-track,
        .table-wrapper::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 6px;
        }
        
        .data-preview::-webkit-scrollbar-thumb,
        .table-wrapper::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 6px;
        }
        
        .data-preview::-webkit-scrollbar-thumb:hover,
        .table-wrapper::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        .data-preview::-webkit-scrollbar-corner,
        .table-wrapper::-webkit-scrollbar-corner {
            background: #f1f1f1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒ GeoJsTool åœ°çƒåŒ–å­¦åˆ†æå·¥å…· - ç½‘é¡µç‰ˆ</h1>
        
        <div class="grid-container">
            <div class="section">
                <h3>ğŸ“Š æ•°æ®ä¸Šä¼ </h3>
                <div class="form-group">
                    <label for="dataFile">é€‰æ‹©æ•°æ®æ–‡ä»¶ (CSV/Excel):</label>
                    <input type="file" id="dataFile" accept=".csv,.xlsx,.xls">
                </div>
                <button onclick="loadData()">ä¸Šä¼ æ•°æ®</button>
                <div id="dataPreview" class="data-preview" style="display:none;"></div>
            </div>

            <div class="section">
                <h3>ğŸ“ˆ å›¾è¡¨ç”Ÿæˆ</h3>
                <div class="form-group">
                    <label for="plotType">å›¾è¡¨ç±»å‹:</label>
                    <select id="plotType" onchange="showOptions()">
                        <option value="">è¯·é€‰æ‹©å›¾è¡¨ç±»å‹</option>
                        <optgroup label="åˆ†ç±»å›¾">
                            <option value="tas">TAS ç«å±±å²©åˆ†ç±»å›¾</option>
                            <option value="qapf">QAPF æ·±æˆå²©åˆ†ç±»å›¾</option>
                        </optgroup>
                        <optgroup label="å˜å¼‚å›¾">
                            <option value="harker">Harker å˜å¼‚å›¾</option>
                        </optgroup>
                        <optgroup label="å¾®é‡å…ƒç´ å›¾è§£">
                            <option value="ree">REE ç¨€åœŸå…ƒç´ æ ‡å‡†åŒ–å›¾</option>
                            <option value="trace">Trace å¾®é‡å…ƒç´ è››ç½‘å›¾</option>
                        </optgroup>
                        <optgroup label="æ„é€ åˆ¤åˆ«å›¾">
                            <option value="pearce">Pearce èŠ±å²—å²©åˆ¤åˆ«å›¾</option>
                        </optgroup>
                        <optgroup label="æ ‡å‡†çŸ¿ç‰©è®¡ç®—">
                            <option value="cipw">CIPW æ ‡å‡†çŸ¿ç‰©è®¡ç®—</option>
                        </optgroup>
                    </select>
                </div>

                <div id="reeOptions" class="options">
                    <div class="form-group">
                        <label for="reeStandard">REE æ ‡å‡†åŒ–æ ‡å‡†:</label>
                        <select id="reeStandard">
                            <option value="C1 Chondrite Sun and McDonough,1989">C1 çƒç²’é™¨çŸ³ (Sun & McDonough, 1989)</option>
                            <option value="Chondrite Taylor and McLennan,1985">çƒç²’é™¨çŸ³ (Taylor & McLennan, 1985)</option>
                            <option value="Chondrite Haskin et al.,1966">çƒç²’é™¨çŸ³ (Haskin et al., 1966)</option>
                            <option value="Chondrite Nakamura,1977">çƒç²’é™¨çŸ³ (Nakamura, 1977)</option>
                            <option value="MORB Sun and McDonough,1989">MORB (Sun & McDonough, 1989)</option>
                            <option value="UCC_Rudnick & Gao2003">ä¸Šåœ°å£³ (Rudnick & Gao, 2003)</option>
                        </select>
                    </div>
                </div>

                <div id="traceOptions" class="options">
                    <div class="form-group">
                        <label for="traceStandard">Trace æ ‡å‡†åŒ–æ ‡å‡†:</label>
                        <select id="traceStandard">
                            <option value="PM">åŸå§‹åœ°å¹” (PM)</option>
                            <option value="OIB">æ´‹å²›ç„æ­¦å²© (OIB)</option>
                            <option value="EMORB">å¯Œé›†å‹æ´‹ä¸­è„Šç„æ­¦å²© (EMORB)</option>
                            <option value="C1">C1 çƒç²’é™¨çŸ³</option>
                            <option value="NMORB">æ­£å¸¸å‹æ´‹ä¸­è„Šç„æ­¦å²© (NMORB)</option>
                            <option value="UCC_Rudnick & Gao2003">ä¸Šåœ°å£³ (Rudnick & Gao, 2003)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="elementSet">å…ƒç´ åºåˆ—:</label>
                        <select id="elementSet">
                            <option value="cs_lu">Cs-Lu (36 å…ƒç´ )</option>
                            <option value="rb_lu">Rb-Lu (26 å…ƒç´ )</option>
                        </select>
                    </div>
                </div>

                <button onclick="generatePlot()" id="plotBtn" disabled>ç”Ÿæˆå›¾è¡¨</button>
                
                <div id="downloadSection" style="display:none; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e2e8f0;">
                    <h4 style="margin: 0 0 10px 0; color: #4a5568; font-size: 14px;">ğŸ“¥ ä¸‹è½½é€‰é¡¹</h4>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button onclick="downloadPlot('png')" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); font-size: 12px; padding: 8px 16px;">ğŸ“¥ ä¸‹è½½ PNG</button>
                        <button onclick="downloadPlot('svg')" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); font-size: 12px; padding: 8px 16px;">ğŸ“¦ ä¸‹è½½ SVG</button>
                        <button onclick="downloadPlot('pdf')" style="background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%); font-size: 12px; padding: 8px 16px;">ğŸ“„ ä¸‹è½½ PDF</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="plotContainer" class="plot-container" style="display:none;">
            <div id="plotDiv" style="height: 600px; width: 100%; min-width: 800px;"></div>
            <div id="downloadButtons" style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button onclick="downloadPlot('png')" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">ğŸ“¥ ä¸‹è½½ PNG</button>
                <button onclick="downloadPlot('svg')" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">ğŸ“¦ ä¸‹è½½ SVG</button>
                <button onclick="downloadPlot('pdf')" style="background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);">ğŸ“„ ä¸‹è½½ PDF</button>
            </div>
        </div>
        
        <div id="cipwResults" class="plot-container" style="display:none;">
            <h3>CIPW æ ‡å‡†çŸ¿ç‰©è®¡ç®—ç»“æœ</h3>
            <div id="cipwTable"></div>
        </div>
    </div>

    <!-- å†…åµŒ CSV è§£æå™¨ -->
    <script>
        // Simple CSV parser implementation - å¢å¼ºç‰ˆæœ¬ï¼Œæ›´å¥½åœ°å¤„ç†ç‰¹æ®Šæƒ…å†µ
        function parseCSV(text) {
            const lines = text.split('\n');
            if (lines.length === 0) return { data: [], meta: { fields: [] } };
            
            // å¤„ç†å¤´éƒ¨ï¼Œå»é™¤BOMå’Œç©ºæ ¼
            let headerLine = lines[0];
            if (headerLine.charCodeAt(0) === 0xFEFF) {
                headerLine = headerLine.substr(1); // å»é™¤BOM
            }
            
            const headers = headerLine.split(',').map(h => h.trim().replace(/"/g, ''));
            console.log('è§£æåˆ°çš„åˆ—å¤´:', headers.length, headers);
            
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line) {
                    const values = line.split(',').map(v => v.trim().replace(/"/g, ''));
                    const row = {};
                    headers.forEach((header, j) => {
                        // ä¿è¯æ¯ä¸ªåˆ—éƒ½æœ‰å€¼ï¼Œå³ä½¿æ˜¯ç©ºå­—ç¬¦ä¸²
                        row[header] = values[j] !== undefined ? values[j] : '';
                    });
                    data.push(row);
                }
            }
            
            console.log('è§£æå®Œæˆ:', data.length, 'è¡Œæ•°æ®ï¼Œæ¯è¡Œ', Object.keys(data[0] || {}).length, 'åˆ—');
            return { data, meta: { fields: headers } };
        }
    </script>

    <!-- Plotly.js CDN -->
    <script src="https://cdn.plot.ly/plotly-2.30.1.min.js"></script>

    <script>
        let globalData = null;
        let currentPlot = null;
        let cipwResultData = null;

        // æ ‡å‡†åŒ–æ•°æ® - å®Œæ•´ç‰ˆæœ¬
        const standards = {
            ree: {
                'C1 Chondrite Sun and McDonough,1989': {
                    'La': 0.237, 'Ce': 0.612, 'Pr': 0.095, 'Nd': 0.467, 'Sm': 0.153,
                    'Eu': 0.058, 'Gd': 0.2055, 'Tb': 0.0374, 'Dy': 0.254, 'Ho': 0.0566,
                    'Er': 0.1655, 'Tm': 0.0255, 'Yb': 0.17, 'Lu': 0.0254
                },
                'Chondrite Taylor and McLennan,1985': {
                    'La': 0.367, 'Ce': 0.957, 'Pr': 0.137, 'Nd': 0.711, 'Sm': 0.231,
                    'Eu': 0.087, 'Gd': 0.306, 'Tb': 0.058, 'Dy': 0.381, 'Ho': 0.0851,
                    'Er': 0.249, 'Tm': 0.0356, 'Yb': 0.248, 'Lu': 0.0381
                },
                'Chondrite Haskin et al.,1966': {
                    'La': 0.32, 'Ce': 0.787, 'Pr': 0.112, 'Nd': 0.58, 'Sm': 0.185, 'Eu': 0.071,
                    'Gd': 0.256, 'Tb': 0.05, 'Dy': 0.343, 'Ho': 0.07, 'Er': 0.225, 'Tm': 0.03,
                    'Yb': 0.186, 'Lu': 0.034
                },
                'Chondrite Nakamura,1977': {
                    'La': 0.33, 'Ce': 0.865, 'Pr': 0.112, 'Nd': 0.63, 'Sm': 0.203, 'Eu': 0.077,
                    'Gd': 0.276, 'Tb': 0.047, 'Dy': 0.343, 'Ho': 0.07, 'Er': 0.225, 'Tm': 0.03,
                    'Yb': 0.22, 'Lu': 0.034
                },
                'MORB Sun and McDonough,1989': {
                    'La': 2.5, 'Ce': 7.5, 'Pr': 1.32, 'Nd': 7.3, 'Sm': 2.63, 'Eu': 1.02, 'Gd': 3.68,
                    'Tb': 0.67, 'Dy': 4.55, 'Ho': 1.052, 'Er': 2.97, 'Tm': 0.46, 'Yb': 3.05, 'Lu': 0.46
                },
                'UCC_Rudnick & Gao2003': {
                    'La': 31, 'Ce': 63, 'Pr': 7.1, 'Nd': 27, 'Sm': 4.7, 'Eu': 1, 'Gd': 4, 'Tb': 0.7,
                    'Dy': 3.9, 'Ho': 0.83, 'Er': 2.3, 'Tm': 0.3, 'Yb': 1.96, 'Lu': 0.31
                }
            },
            trace: {
                'PM': {
                    'Cs': 0.032, 'Tl': 0.005, 'Rb': 0.635, 'Ba': 6.989, 'W': 0.02, 'Th': 0.085, 'U': 0.021, 'Nb': 0.713,
                    'Ta': 0.041, 'K': 250, 'La': 0.687, 'Ce': 1.775, 'Pb': 0.185, 'Pr': 0.276, 'Mo': 0.063, 'Sr': 21.1,
                    'P': 95, 'Nd': 1.354, 'F': 26, 'Sm': 0.444, 'Zr': 11.2, 'Hf': 0.309, 'Eu': 0.168, 'Sn': 0.17,
                    'Sb': 0.005, 'Ti': 1300, 'Gd': 0.596, 'Tb': 0.108, 'Dy': 0.736, 'Li': 1.6, 'Y': 4.55, 'Ho': 0.164,
                    'Er': 0.48, 'Tm': 0.074, 'Yb': 0.493, 'Lu': 0.074
                },
                'OIB': {
                    'Cs': 0.387, 'Tl': 0.077, 'Rb': 31, 'Ba': 350, 'W': 0.56, 'Th': 4, 'U': 1.02, 'Nb': 48, 'Ta': 2.7,
                    'K': 12000, 'La': 36, 'Ce': 80, 'Pb': 3.2, 'Pr': 9.7, 'Mo': 2.4, 'Sr': 660, 'P': 2700, 'Nd': 38.5,
                    'F': 1150, 'Sm': 10, 'Zr': 280, 'Hf': 7.8, 'Eu': 3, 'Sn': 2.7, 'Sb': 0.03, 'Ti': 17200, 'Gd': 7.62,
                    'Tb': 1.05, 'Dy': 5.6, 'Li': 5.6, 'Y': 29, 'Ho': 1.06, 'Er': 2.62, 'Tm': 0.35, 'Yb': 2.16, 'Lu': 0.3
                },
                'EMORB': {
                    'Cs': 0.063, 'Tl': 0.013, 'Rb': 5.04, 'Ba': 57, 'W': 0.092, 'Th': 0.6, 'U': 0.18, 'Nb': 8.3,
                    'Ta': 0.47, 'K': 2100, 'La': 6.3, 'Ce': 15, 'Pb': 0.6, 'Pr': 2.05, 'Mo': 0.47, 'Sr': 155, 'P': 620,
                    'Nd': 9, 'F': 250, 'Sm': 2.6, 'Zr': 73, 'Hf': 2.03, 'Eu': 0.91, 'Sn': 0.8, 'Sb': 0.01, 'Ti': 6000,
                    'Gd': 2.97, 'Tb': 0.53, 'Dy': 3.55, 'Li': 3.5, 'Y': 22, 'Ho': 0.79, 'Er': 2.31, 'Tm': 0.356,
                    'Yb': 2.36, 'Lu': 0.354
                },
                'C1': {
                    'Cs': 0.188, 'Tl': 0.14, 'Rb': 2.32, 'Ba': 2.41, 'W': 0.095, 'Th': 0.029, 'U': 0.008, 'Nb': 0.246,
                    'Ta': 0.014, 'K': 545, 'La': 0.236, 'Ce': 0.612, 'Pb': 2.47, 'Pr': 0.095, 'Mo': 0.92, 'Sr': 7.26,
                    'P': 1220, 'Nd': 0.467, 'F': 60.7, 'Sm': 0.153, 'Zr': 3.87, 'Hf': 0.1066, 'Eu': 0.058, 'Sn': 1.72,
                    'Sb': 0.16, 'Ti': 445, 'Gd': 0.2055, 'Tb': 0.0364, 'Dy': 0.254, 'Li': 1.57, 'Y': 1.57, 'Ho': 0.0566,
                    'Er': 0.1655, 'Tm': 0.0255, 'Yb': 0.17, 'Lu': 0.0254
                },
                'NMORB': {
                    'Cs': 0.007, 'Tl': 0.0014, 'Rb': 0.56, 'Ba': 6.3, 'W': 0.01, 'Th': 0.12, 'U': 0.047, 'Nb': 2.33,
                    'Ta': 0.132, 'K': 600, 'La': 2.5, 'Ce': 7.5, 'Pb': 0.3, 'Pr': 1.32, 'Mo': 0.31, 'Sr': 90, 'P': 510,
                    'Nd': 7.3, 'F': 210, 'Sm': 2.63, 'Zr': 74, 'Hf': 2.05, 'Eu': 1.02, 'Sn': 1.1, 'Sb': 0.01, 'Ti': 7600,
                    'Gd': 3.68, 'Tb': 0.67, 'Dy': 4.55, 'Li': 4.3, 'Y': 28, 'Ho': 1.01, 'Er': 2.97, 'Tm': 0.456,
                    'Yb': 3.05, 'Lu': 0.455
                },
                'UCC_Rudnick & Gao2003': {
                    'K': 23244.13676, 'Ti': 3835.794545, 'P': 654.6310022, 'Li': 24, 'Be': 2.1, 'B': 17, 'N': 83, 'F': 557, 'S': 62, 'Cl': 360, 'Sc': 14, 'V': 97, 'Cr': 92,
                    'Co': 17.3, 'Ni': 47, 'Cu': 28, 'Zn': 67, 'Ga': 17.5, 'Ge': 1.4, 'As': 4.8, 'Se': 0.09,
                    'Br': 1.6, 'Rb': 84, 'Sr': 320, 'Y': 21, 'Zr': 193, 'Nb': 12, 'Mo': 1.1, 'Ru': 0.34,
                    'Pd': 0.52, 'Ag': 53, 'Cd': 0.09, 'In': 0.056, 'Sn': 2.1, 'Sb': 0.4, 'I': 1.4, 'Cs': 4.9,
                    'Ba': 628, 'La': 31, 'Ce': 63, 'Pr': 7.1, 'Nd': 27, 'Sm': 4.7, 'Eu': 1, 'Gd': 4, 'Tb': 0.7,
                    'Dy': 3.9, 'Ho': 0.83, 'Er': 2.3, 'Tm': 0.3, 'Yb': 1.96, 'Lu': 0.31, 'Hf': 5.3, 'Ta': 0.9,
                    'W': 1.9, 'Re': 0.198, 'Os': 0.031, 'Ir': 0.022, 'Pt': 0.5, 'Au': 1.5, 'Hg': 0.05, 'Tl': 0.9,
                    'Pb': 17, 'Bi': 0.16, 'Th': 10.5, 'U': 2.7
                }
            }
        };

        const elementSets = {
            'cs_lu': ['Cs', 'Tl', 'Rb', 'Ba', 'W', 'Th', 'U', 'Nb', 'Ta', 'K', 'La', 'Ce', 'Pb', 'Pr', 'Mo',
                     'Sr', 'P', 'Nd', 'F', 'Sm', 'Zr', 'Hf', 'Eu', 'Sn', 'Sb', 'Ti', 'Gd', 'Tb', 'Dy',
                     'Li', 'Y', 'Ho', 'Er', 'Tm', 'Yb', 'Lu'],
            'rb_lu': ['Rb', 'Ba', 'Th', 'U', 'Nb', 'Ta', 'K', 'La', 'Ce', 'Pr', 'Sr', 'P', 'Nd',
                     'Zr', 'Hf', 'Sm', 'Eu', 'Ti', 'Tb', 'Dy', 'Y', 'Ho', 'Er', 'Tm', 'Yb', 'Lu']
        };

        // è·å–åˆ†ç±»åˆ— - ä¼˜å…ˆä½¿ç”¨ç²¾ç¡®çš„Labelåˆ—åï¼Œå…¶æ¬¡Type
        function getClassificationColumn() {
            if (!globalData || globalData.length === 0) return null;
            
            const firstRow = globalData[0];
            const columns = Object.keys(firstRow);
            
            // ä¼˜å…ˆæŸ¥æ‰¾ç²¾ç¡®çš„ Label åˆ—
            if (columns.includes('Label')) {
                return 'Label';
            }
            
            // å…¶æ¬¡æŸ¥æ‰¾ Label åˆ—ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
            for (let col of columns) {
                if (col.toLowerCase().trim() === 'label') {
                    return col;
                }
            }
            
            // æœ€åæŸ¥æ‰¾ Type åˆ—ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
            for (let col of columns) {
                if (col.toLowerCase().trim() === 'type') {
                    return col;
                }
            }
            
            return null; // æ²¡æœ‰æ‰¾åˆ°åˆ†ç±»åˆ—
        }
        
        // è·å–é¢œè‰²æ˜ å°„å’Œæ ‡ç­¾ - ä¼˜å…ˆä½¿ç”¨ç²¾ç¡®çš„Coloråˆ—
        function getColorMapping() {
            if (!globalData || globalData.length === 0) {
                return { colors: [], labels: [], legendItems: [] };
            }
            
            const classificationCol = getClassificationColumn();
            
            // ä¼˜å…ˆæŸ¥æ‰¾ç²¾ç¡®çš„ Color åˆ—
            let colorCol = null;
            const columns = Object.keys(globalData[0]);
            
            if (columns.includes('Color')) {
                colorCol = 'Color';
            } else if (columns.some(col => col.toLowerCase() === 'color')) {
                colorCol = columns.find(col => col.toLowerCase() === 'color');
            }
            
            const defaultColors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', 
                           '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94'];
            
            if (classificationCol) {
                // ä½¿ç”¨åˆ†ç±»åˆ—è¿›è¡Œåˆ†ç»„
                const uniqueValues = [...new Set(globalData.map(row => row[classificationCol] || 'Unknown'))];
                const colorMap = {};
                const legendItems = [];
                
                if (colorCol) {
                    // å¦‚æœColoråˆ—å­˜åœ¨ï¼Œä½¿ç”¨æ•°æ®ä¸­æŒ‡å®šçš„é¢œè‰²
                    uniqueValues.forEach((value, index) => {
                        // æ‰¾åˆ°ç¬¬ä¸€ä¸ªè¯¥åˆ†ç±»çš„æ ·æœ¬çš„é¢œè‰²
                        const sampleWithValue = globalData.find(row => (row[classificationCol] || 'Unknown') === value);
                        let color = sampleWithValue && sampleWithValue[colorCol] ? sampleWithValue[colorCol] : defaultColors[index % defaultColors.length];
                        
                        // å¤„ç†å¸¸è§é¢œè‰²åç§°å’Œæ ¼å¼
                        if (typeof color === 'string') {
                            color = color.trim();
                            // å¦‚æœæ˜¯å¸¸è§é¢œè‰²åï¼Œè½¬æ¢ä¸ºå°å†™ä½†ä¿æŒæ ¼å¼
                            const colorNameMap = {
                                'red': '#ff0000', 'blue': '#0000ff', 'green': '#008000', 'yellow': '#ffff00',
                                'orange': '#ffa500', 'purple': '#800080', 'pink': '#ffc0cb', 'brown': '#a52a2a',
                                'black': '#000000', 'white': '#ffffff', 'gray': '#808080', 'grey': '#808080'
                            };
                            const lowerColor = color.toLowerCase();
                            if (colorNameMap[lowerColor]) {
                                color = colorNameMap[lowerColor];
                            }
                        }
                        
                        colorMap[value] = color;
                        legendItems.push({
                            label: value.toString(),
                            color: color
                        });
                    });
                } else {
                    // æ²¡æœ‰Coloråˆ—ï¼Œä½¿ç”¨é»˜è®¤é¢œè‰²
                    uniqueValues.forEach((value, index) => {
                        colorMap[value] = defaultColors[index % defaultColors.length];
                        legendItems.push({
                            label: value.toString(),
                            color: defaultColors[index % defaultColors.length]
                        });
                    });
                }
                
                const sampleColors = globalData.map(row => {
                    const value = row[classificationCol] || 'Unknown';
                    return colorMap[value];
                });
                
                const sampleLabels = globalData.map(row => {
                    const value = row[classificationCol] || 'Unknown';
                    return value.toString();
                });
                
                return { colors: sampleColors, labels: sampleLabels, legendItems };
            } else {
                // æ²¡æœ‰åˆ†ç±»åˆ—ï¼ŒæŒ‰æ ·å“ç¼–å·ç»˜åˆ¶
                const sampleColors = globalData.map((row, i) => {
                    if (colorCol && row[colorCol]) {
                        let color = row[colorCol];
                        if (typeof color === 'string') {
                            color = color.trim();
                            const colorNameMap = {
                                'red': '#ff0000', 'blue': '#0000ff', 'green': '#008000', 'yellow': '#ffff00',
                                'orange': '#ffa500', 'purple': '#800080', 'pink': '#ffc0cb', 'brown': '#a52a2a',
                                'black': '#000000', 'white': '#ffffff', 'gray': '#808080', 'grey': '#808080'
                            };
                            const lowerColor = color.toLowerCase();
                            if (colorNameMap[lowerColor]) {
                                color = colorNameMap[lowerColor];
                            }
                        }
                        return color;
                    }
                    return defaultColors[i % defaultColors.length];
                });
                
                const sampleLabels = globalData.map((_, i) => `æ ·å“ ${i + 1}`);
                const legendItems = globalData.map((row, i) => ({
                    label: `æ ·å“ ${i + 1}`,
                    color: sampleColors[i]
                }));
                
                return { colors: sampleColors, labels: sampleLabels, legendItems };
            }
        }

        // æç¤ºä¿¡æ¯å‡½æ•°
        function showAlert(message, type) {
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.textContent = message;
            document.querySelector('.container').insertBefore(alert, document.querySelector('.container').firstChild);
            setTimeout(() => alert.remove(), 5000);
        }

        // æ•°æ®åŠ è½½å‡½æ•°
        function loadData() {
            const file = document.getElementById('dataFile').files[0];
            if (!file) {
                showAlert('è¯·é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶ï¼', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    if (file.name.endsWith('.csv')) {
                        const csv = parseCSV(e.target.result);
                        globalData = csv.data;
                        console.log('CSVè§£æå®Œæˆ:', {
                            'åŸå§‹åˆ—æ•°': csv.meta.fields.length,
                            'åŸå§‹åˆ—å': csv.meta.fields,
                            'æ•°æ®è¡Œæ•°': globalData.length
                        });
                    } else {
                        showAlert('ç›®å‰åªæ”¯æŒ CSV æ–‡ä»¶æ ¼å¼', 'error');
                        return;
                    }
                    
                    if (globalData && globalData.length > 0) {
                        standardizeColumns();
                        displayDataPreview();
                        document.getElementById('plotBtn').disabled = false;
                        document.getElementById('downloadSection').style.display = 'none'; // éšè—ä¸‹è½½åŒºåŸŸ
                        showAlert(`æ•°æ®åŠ è½½æˆåŠŸï¼å…± ${globalData.length} è¡Œæ•°æ®ï¼Œ${Object.keys(globalData[0]).length} ä¸ªå­—æ®µ`, 'success');
                    }
                } catch (error) {
                    showAlert('æ–‡ä»¶è¯»å–å¤±è´¥ï¼š' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        // æ ‡å‡†åŒ–åˆ—å - å¢å¼ºç‰ˆæœ¬ï¼Œå¤„ç†å„ç§æ ¼å¼
        function standardizeColumns() {
            // å®Œæ•´çš„åˆ—åæ˜ å°„è¡¨ï¼ŒåŒ…å«å„ç§å¯èƒ½çš„å˜ä½“
            const columnMapping = {
                // SiO2 çš„å„ç§å˜ä½“
                'sio2': 'SiO2', 'SIO2': 'SiO2', 'si02': 'SiO2', 'SI02': 'SiO2',
                'sio2(wt%)': 'SiO2', 'sio2(wt.%)': 'SiO2', 'sio2(%)': 'SiO2', 'sio2è´¨é‡åˆ†æ•°': 'SiO2',
                'sio2_wt%': 'SiO2', 'sio2_wt': 'SiO2', 'sio2_weight%': 'SiO2', 'sio2å«é‡': 'SiO2',
                
                // TiO2 çš„å„ç§å˜ä½“
                'tio2': 'TiO2', 'TIO2': 'TiO2', 'ti02': 'TiO2', 'TI02': 'TiO2',
                'tio2(wt%)': 'TiO2', 'tio2(wt.%)': 'TiO2', 'tio2(%)': 'TiO2', 'tio2è´¨é‡åˆ†æ•°': 'TiO2',
                'tio2_wt%': 'TiO2', 'tio2_wt': 'TiO2', 'tio2_weight%': 'TiO2', 'tio2å«é‡': 'TiO2',
                
                // Al2O3 çš„å„ç§å˜ä½“
                'al2o3': 'Al2O3', 'AL2O3': 'Al2O3', 'al203': 'Al2O3', 'AL203': 'Al2O3',
                'al2o3(wt%)': 'Al2O3', 'al2o3(wt.%)': 'Al2O3', 'al2o3(%)': 'Al2O3', 'al2o3è´¨é‡åˆ†æ•°': 'Al2O3',
                'al2o3_wt%': 'Al2O3', 'al2o3_wt': 'Al2O3', 'al2o3_weight%': 'Al2O3', 'al2o3å«é‡': 'Al2O3',
                
                // Fe2O3 çš„å„ç§å˜ä½“
                'fe2o3': 'Fe2O3', 'FE2O3': 'Fe2O3', 'fe203': 'Fe2O3', 'FE203': 'Fe2O3',
                'fe2o3(wt%)': 'Fe2O3', 'fe2o3(wt.%)': 'Fe2O3', 'fe2o3(%)': 'Fe2O3', 'fe2o3è´¨é‡åˆ†æ•°': 'Fe2O3',
                'fe2o3_wt%': 'Fe2O3', 'fe2o3_wt': 'Fe2O3', 'fe2o3_weight%': 'Fe2O3', 'fe2o3å«é‡': 'Fe2O3',
                
                // FeO çš„å„ç§å˜ä½“
                'feo': 'FeO', 'FEO': 'FeO',
                'feo(wt%)': 'FeO', 'feo(wt.%)': 'FeO', 'feo(%)': 'FeO', 'feoè´¨é‡åˆ†æ•°': 'FeO',
                'feo_wt%': 'FeO', 'feo_wt': 'FeO', 'feo_weight%': 'FeO', 'feoå«é‡': 'FeO',
                
                // MnO çš„å„ç§å˜ä½“
                'mno': 'MnO', 'MNO': 'MnO',
                'mno(wt%)': 'MnO', 'mno(wt.%)': 'MnO', 'mno(%)': 'MnO', 'mnoè´¨é‡åˆ†æ•°': 'MnO',
                'mno_wt%': 'MnO', 'mno_wt': 'MnO', 'mno_weight%': 'MnO', 'mnoå«é‡': 'MnO',
                
                // MgO çš„å„ç§å˜ä½“
                'mgo': 'MgO', 'MGO': 'MgO',
                'mgo(wt%)': 'MgO', 'mgo(wt.%)': 'MgO', 'mgo(%)': 'MgO', 'mgoè´¨é‡åˆ†æ•°': 'MgO',
                'mgo_wt%': 'MgO', 'mgo_wt': 'MgO', 'mgo_weight%': 'MgO', 'mgoå«é‡': 'MgO',
                
                // CaO çš„å„ç§å˜ä½“
                'cao': 'CaO', 'CAO': 'CaO',
                'cao(wt%)': 'CaO', 'cao(wt.%)': 'CaO', 'cao(%)': 'CaO', 'caoè´¨é‡åˆ†æ•°': 'CaO',
                'cao_wt%': 'CaO', 'cao_wt': 'CaO', 'cao_weight%': 'CaO', 'caoå«é‡': 'CaO',
                
                // Na2O çš„å„ç§å˜ä½“
                'na2o': 'Na2O', 'NA2O': 'Na2O', 'na20': 'Na2O', 'NA20': 'Na2O',
                'na2o(wt%)': 'Na2O', 'na2o(wt.%)': 'Na2O', 'na2o(%)': 'Na2O', 'na2oè´¨é‡åˆ†æ•°': 'Na2O',
                'na2o_wt%': 'Na2O', 'na2o_wt': 'Na2O', 'na2o_weight%': 'Na2O', 'na2oå«é‡': 'Na2O',
                
                // K2O çš„å„ç§å˜ä½“
                'k2o': 'K2O', 'K2O': 'K2O', 'k20': 'K2O', 'K20': 'K2O',
                'k2o(wt%)': 'K2O', 'k2o(wt.%)': 'K2O', 'k2o(%)': 'K2O', 'k2oè´¨é‡åˆ†æ•°': 'K2O',
                'k2o_wt%': 'K2O', 'k2o_wt': 'K2O', 'k2o_weight%': 'K2O', 'k2oå«é‡': 'K2O',
                
                // P2O5 çš„å„ç§å˜ä½“
                'p2o5': 'P2O5', 'P2O5': 'P2O5', 'p205': 'P2O5', 'P205': 'P2O5',
                'p2o5(wt%)': 'P2O5', 'p2o5(wt.%)': 'P2O5', 'p2o5(%)': 'P2O5', 'p2o5è´¨é‡åˆ†æ•°': 'P2O5',
                'p2o5_wt%': 'P2O5', 'p2o5_wt': 'P2O5', 'p2o5_weight%': 'P2O5', 'p2o5å«é‡': 'P2O5',
                
                // å¾®é‡å…ƒç´ çš„å„ç§å˜ä½“
                // Rb
                'rb': 'Rb', 'RB': 'Rb',
                'rb(ppm)': 'Rb', 'rb(ppb)': 'Rb', 'rb_ppm': 'Rb', 'rb_ppb': 'Rb', 'rbå«é‡': 'Rb',
                
                // Ba
                'ba': 'Ba', 'BA': 'Ba',
                'ba(ppm)': 'Ba', 'ba(ppb)': 'Ba', 'ba_ppm': 'Ba', 'ba_ppb': 'Ba', 'baå«é‡': 'Ba',
                
                // Th
                'th': 'Th', 'TH': 'Th',
                'th(ppm)': 'Th', 'th(ppb)': 'Th', 'th_ppm': 'Th', 'th_ppb': 'Th', 'thå«é‡': 'Th',
                
                // U
                'u': 'U', 'U': 'U',
                'u(ppm)': 'U', 'u(ppb)': 'U', 'u_ppm': 'U', 'u_ppb': 'U', 'uå«é‡': 'U',
                
                // Nb
                'nb': 'Nb', 'NB': 'Nb',
                'nb(ppm)': 'Nb', 'nb(ppb)': 'Nb', 'nb_ppm': 'Nb', 'nb_ppb': 'Nb', 'nbå«é‡': 'Nb',
                
                // Ta
                'ta': 'Ta', 'TA': 'Ta',
                'ta(ppm)': 'Ta', 'ta(ppb)': 'Ta', 'ta_ppm': 'Ta', 'ta_ppb': 'Ta', 'taå«é‡': 'Ta',
                
                // Y
                'y': 'Y', 'Y': 'Y',
                'y(ppm)': 'Y', 'y(ppb)': 'Y', 'y_ppm': 'Y', 'y_ppb': 'Y', 'yå«é‡': 'Y',
                
                // Zr
                'zr': 'Zr', 'ZR': 'Zr',
                'zr(ppm)': 'Zr', 'zr(ppb)': 'Zr', 'zr_ppm': 'Zr', 'zr_ppb': 'Zr', 'zrå«é‡': 'Zr',
                
                // Sr
                'sr': 'Sr', 'SR': 'Sr',
                'sr(ppm)': 'Sr', 'sr(ppb)': 'Sr', 'sr_ppm': 'Sr', 'sr_ppb': 'Sr', 'srå«é‡': 'Sr',
                
                // REE å…ƒç´ çš„å„ç§å˜ä½“
                'la': 'La', 'LA': 'La', 'la(ppm)': 'La', 'la_ppm': 'La', 'laå«é‡': 'La',
                'ce': 'Ce', 'CE': 'Ce', 'ce(ppm)': 'Ce', 'ce_ppm': 'Ce', 'ceå«é‡': 'Ce',
                'pr': 'Pr', 'PR': 'Pr', 'pr(ppm)': 'Pr', 'pr_ppm': 'Pr', 'prå«é‡': 'Pr',
                'nd': 'Nd', 'ND': 'Nd', 'nd(ppm)': 'Nd', 'nd_ppm': 'Nd', 'ndå«é‡': 'Nd',
                'sm': 'Sm', 'SM': 'Sm', 'sm(ppm)': 'Sm', 'sm_ppm': 'Sm', 'små«é‡': 'Sm',
                'eu': 'Eu', 'EU': 'Eu', 'eu(ppm)': 'Eu', 'eu_ppm': 'Eu', 'euå«é‡': 'Eu',
                'gd': 'Gd', 'GD': 'Gd', 'gd(ppm)': 'Gd', 'gd_ppm': 'Gd', 'gdå«é‡': 'Gd',
                'tb': 'Tb', 'TB': 'Tb', 'tb(ppm)': 'Tb', 'tb_ppm': 'Tb', 'tbå«é‡': 'Tb',
                'dy': 'Dy', 'DY': 'Dy', 'dy(ppm)': 'Dy', 'dy_ppm': 'Dy', 'dyå«é‡': 'Dy',
                'ho': 'Ho', 'HO': 'Ho', 'ho(ppm)': 'Ho', 'ho_ppm': 'Ho', 'hoå«é‡': 'Ho',
                'er': 'Er', 'ER': 'Er', 'er(ppm)': 'Er', 'er_ppm': 'Er', 'erå«é‡': 'Er',
                'tm': 'Tm', 'TM': 'Tm', 'tm(ppm)': 'Tm', 'tm_ppm': 'Tm', 'tmå«é‡': 'Tm',
                'yb': 'Yb', 'YB': 'Yb', 'yb(ppm)': 'Yb', 'yb_ppm': 'Yb', 'ybå«é‡': 'Yb',
                'lu': 'Lu', 'LU': 'Lu', 'lu(ppm)': 'Lu', 'lu_ppm': 'Lu', 'luå«é‡': 'Lu',
                
                // å…¶ä»–å¸¸è§å…ƒç´ 
                'pb': 'Pb', 'PB': 'Pb', 'pb(ppm)': 'Pb', 'pb_ppm': 'Pb', 'pbå«é‡': 'Pb',
                'cs': 'Cs', 'CS': 'Cs', 'cs(ppm)': 'Cs', 'cs_ppm': 'Cs', 'cså«é‡': 'Cs',
                'loi': 'LOI', 'LOI': 'LOI', 'total': 'Total', 'TOTAL': 'Total', 'sum': 'Total'
            };

            // æ™ºèƒ½åˆ—åè¯†åˆ«å‡½æ•° - ä¿æŠ¤ç‰¹å®šå¯è§†åŒ–æ§åˆ¶åˆ—ä¸è¢«ä¿®æ”¹
            function smartColumnMapping(originalCol) {
                // ä¿æŠ¤çš„å¯è§†åŒ–æ§åˆ¶åˆ—ï¼Œè¿™äº›åˆ—åç»å¯¹ä¸èƒ½è¢«ä¿®æ”¹
                const protectedColumns = ['Label', 'Color', 'Marker', 'Size', 'Width', 'Style', 'Alpha', 'Age(ma)'];
                
                // å¦‚æœæ˜¯ä¿æŠ¤åˆ—ï¼Œç›´æ¥è¿”å›åŸå§‹åˆ—å
                if (protectedColumns.includes(originalCol)) {
                    return originalCol;
                }
                
                // æ¸…ç†åˆ—åï¼šå»é™¤ç©ºæ ¼ã€ç‰¹æ®Šå­—ç¬¦ã€å•ä½ç­‰
                let cleaned = originalCol.trim().toLowerCase();
                
                // ç§»é™¤å¸¸è§çš„å•ä½å’Œæ‹¬å·å†…å®¹
                cleaned = cleaned.replace(/[\s\(\)\[\]\{\}]/g, '');
                cleaned = cleaned.replace(/wt%?|weight%?|è´¨é‡åˆ†æ•°|å«é‡|æµ“åº¦/g, '');
                cleaned = cleaned.replace(/ppm|ppb|ppt|mg\/kg|Î¼g\/g/g, '');
                cleaned = cleaned.replace(/[_%\-]/g, '');
                
                // ç›´æ¥æŸ¥æ‰¾æ˜ å°„
                if (columnMapping[cleaned]) {
                    return columnMapping[cleaned];
                }
                
                // æ¨¡ç³ŠåŒ¹é…ä¸»è¦å…ƒç´ 
                const elements = {
                    'sio2': 'SiO2', 'tio2': 'TiO2', 'al2o3': 'Al2O3', 'fe2o3': 'Fe2O3', 'feo': 'FeO',
                    'mno': 'MnO', 'mgo': 'MgO', 'cao': 'CaO', 'na2o': 'Na2O', 'k2o': 'K2O', 'p2o5': 'P2O5',
                    'rb': 'Rb', 'ba': 'Ba', 'th': 'Th', 'u': 'U', 'nb': 'Nb', 'ta': 'Ta', 'y': 'Y', 'zr': 'Zr', 'sr': 'Sr',
                    'la': 'La', 'ce': 'Ce', 'pr': 'Pr', 'nd': 'Nd', 'sm': 'Sm', 'eu': 'Eu', 'gd': 'Gd',
                    'tb': 'Tb', 'dy': 'Dy', 'ho': 'Ho', 'er': 'Er', 'tm': 'Tm', 'yb': 'Yb', 'lu': 'Lu',
                    'pb': 'Pb', 'cs': 'Cs'
                };
                
                for (let [key, value] of Object.entries(elements)) {
                    if (cleaned.includes(key)) {
                        return value;
                    }
                }
                
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…ï¼Œè¿”å›åŸå§‹åˆ—å
                return originalCol;
            }

            // åº”ç”¨æ™ºèƒ½åˆ—åæ˜ å°„ï¼Œä½†ä¿ç•™æ‰€æœ‰åŸå§‹åˆ—é¿å…é‡å¤è¦†ç›–
            const originalColumns = Object.keys(globalData[0]);
            console.log('åŸå§‹åˆ—æ•°:', originalColumns.length, 'åˆ—å:', originalColumns);
            
            globalData = globalData.map(row => {
                const newRow = {};
                const usedStandardNames = new Set();
                
                Object.keys(row).forEach(originalKey => {
                    const standardKey = smartColumnMapping(originalKey);
                    
                    // å¦‚æœæ ‡å‡†åŒ–åç§°å·²ç»ä½¿ç”¨è¿‡ï¼Œä¿ç•™åŸå§‹åç§°é¿å…è¦†ç›–
                    if (usedStandardNames.has(standardKey) && standardKey !== originalKey) {
                        newRow[originalKey] = row[originalKey];
                    } else {
                        newRow[standardKey] = row[originalKey];
                        usedStandardNames.add(standardKey);
                    }
                });
                return newRow;
            });
            
            // è¾“å‡ºæ˜ å°„ä¿¡æ¯ä¾›è°ƒè¯•
            console.log('åˆ—åæ˜ å°„å®Œæˆï¼Œå¤„ç†ååˆ—æ•°:', Object.keys(globalData[0]).length, 'åˆ—å:', Object.keys(globalData[0]));
        }

        function displayDataPreview() {
            const preview = document.getElementById('dataPreview');
            const columns = Object.keys(globalData[0]);
            
            // Display all rows and columns with scrolling - ä¿æŒåŸå§‹æ•°æ®æ˜¾ç¤º
            let html = '<div class="table-wrapper"><table><thead><tr>';
            columns.forEach(col => {
                html += `<th title="${col}">${col}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Display ALL rows instead of limiting to 10 - æ˜¾ç¤ºåŸå§‹æ•°æ®å€¼ï¼Œä¸åšä»»ä½•ä¿®æ”¹
            globalData.forEach(row => {
                html += '<tr>';
                columns.forEach(col => {
                    const value = row[col] || '';
                    // å®Œå…¨æŒ‰åŸå§‹æ•°æ®æ˜¾ç¤ºï¼Œä¸åšä»»ä½•æ ¼å¼åŒ–æˆ–æˆªå–
                    html += `<td title="${value}">${value}</td>`;
                });
                html += '</tr>';
            });

            html += '</tbody></table></div>';
            html += `<p style="text-align: center; margin: 5px; color: #666; font-size: 10px;">å…± ${globalData.length} è¡Œ Ã— ${columns.length} åˆ—æ•°æ®ï¼Œå¯ä¸Šä¸‹å·¦å³æ»‘åŠ¨æŸ¥çœ‹</p>`;

            preview.innerHTML = html;
            preview.style.display = 'block';
        }

        function showOptions() {
            const plotType = document.getElementById('plotType').value;
            ['reeOptions', 'traceOptions'].forEach(id => {
                document.getElementById(id).style.display = 'none';
            });
            
            // éšè—ä¸‹è½½åŒºåŸŸå½“é€‰æ‹©æ–°çš„å›¾è¡¨ç±»å‹æ—¶
            document.getElementById('downloadSection').style.display = 'none';
            
            if (plotType === 'ree') {
                document.getElementById('reeOptions').style.display = 'block';
            } else if (plotType === 'trace') {
                document.getElementById('traceOptions').style.display = 'block';
            }
        }

        function generatePlot() {
            const plotType = document.getElementById('plotType').value;
            if (!plotType || !globalData) {
                showAlert('è¯·é€‰æ‹©å›¾è¡¨ç±»å‹å¹¶ä¸Šä¼ æ•°æ®', 'error');
                return;
            }

            try {
                switch (plotType) {
                    case 'tas': generateTASPlot(); break;
                    case 'harker': generateHarkerPlot(); break;
                    case 'ree': generateREEPlot(); break;
                    case 'trace': generateTracePlot(); break;
                    case 'pearce': generatePearcePlot(); break;
                    case 'cipw': generateCIPWCalculation(); break;
                    case 'qapf': generateQAPFPlot(); break;
                    default: showAlert('æœªçŸ¥çš„å›¾è¡¨ç±»å‹', 'error');
                }
            } catch (error) {
                showAlert('å›¾è¡¨ç”Ÿæˆå¤±è´¥ï¼š' + error.message, 'error');
            }
        }

        // TAS å›¾è¡¨ç”Ÿæˆ - ä¸¥æ ¼æŒ‰ç…§ run.py ä¸­çš„å®ç°
        function generateTASPlot() {
            const requiredCols = ['SiO2', 'Na2O', 'K2O'];
            const missingCols = requiredCols.filter(col => !globalData[0].hasOwnProperty(col));
            if (missingCols.length > 0) {
                showAlert(`ç¼ºå°‘å¿…éœ€çš„åˆ—ï¼š${missingCols.join(', ')}`, 'error');
                return;
            }

            const x = globalData.map(row => parseFloat(row.SiO2));
            const y = globalData.map(row => parseFloat(row.Na2O) + parseFloat(row.K2O));

            // æ•°æ®ç‚¹è¿¹è¸ª
            const traces = [];
            const colorMapping = getColorMapping();
            
            // æ ¹æ®åˆ†ç±»åˆ—å¯¹æ ·å“è¿›è¡Œåˆ†ç»„
            const classificationCol = getClassificationColumn();
            
            if (classificationCol) {
                // æœ‰åˆ†ç±»åˆ—ï¼ŒæŒ‰åˆ†ç±»ç»˜åˆ¶
                const groups = {};
                globalData.forEach((row, i) => {
                    const groupValue = row[classificationCol] || 'Unknown';
                    if (!groups[groupValue]) {
                        groups[groupValue] = { x: [], y: [], indices: [] };
                    }
                    groups[groupValue].x.push(x[i]);
                    groups[groupValue].y.push(y[i]);
                    groups[groupValue].indices.push(i);
                });
                
                // ä¸ºæ¯ä¸ªåˆ†ç»„åˆ›å»º trace
                Object.keys(groups).forEach((groupName) => {
                    const group = groups[groupName];
                    const color = colorMapping.legendItems.find(item => item.label === groupName)?.color || '#1f77b4';
                    
                    traces.push({
                        x: group.x,
                        y: group.y,
                        mode: 'markers',
                        type: 'scatter',
                        marker: { 
                            size: 8, 
                            color: color, 
                            opacity: 0.8, 
                            line: { color: 'black', width: 0.5 } 
                        },
                        name: groupName,
                        showlegend: true
                    });
                });
            } else {
                // æ²¡æœ‰åˆ†ç±»åˆ—ï¼ŒæŒ‰æ ·å“ç¼–å·ç»˜åˆ¶
                for (let i = 0; i < globalData.length; i++) {
                    traces.push({
                        x: [x[i]], 
                        y: [y[i]], 
                        mode: 'markers', 
                        type: 'scatter',
                        marker: { 
                            size: 8, 
                            color: colorMapping.colors[i], 
                            opacity: 0.8, 
                            line: { color: 'black', width: 0.5 } 
                        },
                        name: colorMapping.labels[i],
                        showlegend: globalData.length <= 10  // åªæœ‰æ ·å“æ•°å°‘äºç­‰äº10æ—¶æ‰æ˜¾ç¤ºå›¾ä¾‹
                    });
                }
            }

            // TASåˆ†ç±»çº¿ - ç²¾ç¡®åæ ‡æ¥è‡ª TAS.py
            const tasLines = [
                [[41, 0], [41, 3], [45, 3]],
                [[45, 0], [45, 3], [45, 5], [49.4, 7.3], [53, 9.3], [57.6, 11.7], [61, 13.5], [63, 16.2]],
                [[52, 5], [57, 5.9], [63, 7], [69, 8], [71.8, 13.5], [61, 8.6]],
                [[45, 2], [45, 5], [52, 5], [45, 2]],
                [[69, 8], [77.3, 0], [87.5, 4.7], [85.9, 6.8], [71.8, 13.5], [63, 16.2], [57, 18], [52.5, 18], [37, 14], [35, 9], [37, 3], [41, 3]],
                [[63, 0], [63, 7], [57.6, 11.7], [52.5, 14], [52.5, 18]],
                [[57, 0], [57, 5.9], [53, 9.3], [48.4, 11.5]],
                [[52, 0], [52, 5], [49.4, 7.3], [45, 9.4]],
                [[41, 3], [41, 7], [45, 9.4]],
                [[45, 9.4], [48.4, 11.5], [52.5, 14]]
            ];
            
            // ç»˜åˆ¶ TAS åˆ†ç±»çº¿
            tasLines.forEach(line => {
                const x_coords = line.map(point => point[0]);
                const y_coords = line.map(point => point[1]);
                traces.push({
                    x: x_coords, y: y_coords, mode: 'lines', type: 'scatter',
                    line: { color: 'black', width: 1 },
                    showlegend: false, hoverinfo: 'skip'
                });
            });

            // Irvine-Baragar çº¿ - ç²¾ç¡®å…¬å¼æ¥è‡ª TAS.py
            const irvine_x = [];
            const irvine_y = [];
            const a = 39.0, b = 3.9492, c = -2.1111, d = 0.86096, e = -0.15188, f = 0.012030, g = -3.3539e-5;
            
            for (let y_val = 0; y_val <= 10.2; y_val += 0.1) {
                const x_val = a + b * Math.pow(y_val, 1) + c * Math.pow(y_val, 2) + d * Math.pow(y_val, 3) + 
                             e * Math.pow(y_val, 4) + f * Math.pow(y_val, 5) + g * Math.pow(y_val, 6);
                irvine_x.push(x_val);
                irvine_y.push(y_val);
            }

            traces.push({
                x: irvine_x, y: irvine_y, mode: 'lines', type: 'scatter',
                line: { color: 'black', width: 1, dash: 'dot' },
                name: 'Irvine & Baragar (1971)', showlegend: false, hoverinfo: 'skip'
            });

            const layout = {
                title: 'TAS (Total Alkaliâ€“Silica) Diagram Volcanic (Wilson et al. 1989)',
                width: 900,
                height: 700,
                xaxis: { 
                    title: 'SiOâ‚‚ wt%', 
                    range: [30, 90],
                    tickvals: [30, 40, 50, 60, 70, 80, 90]
                },
                yaxis: { 
                    title: 'Naâ‚‚O + Kâ‚‚O wt%', 
                    range: [0, 20],
                    tickvals: [0, 5, 10, 15, 20]
                },
                showlegend: true  // ç¡®ä¿æ˜¾ç¤ºå›¾ä¾‹
            };

            // æ·»åŠ å²©çŸ³ç±»å‹æ ‡æ³¨ - ç²¾ç¡®ä½ç½®æ¥è‡ª TAS.py
            const locations = [[39, 10], [43, 1.5], [44, 6], [47.5, 3.5], [49.5, 1.5], [49, 5.2], [49, 9.5], 
                              [54, 3], [53, 7], [53, 12], [60, 4], [57, 8.5], [57, 14], [67, 5], [65, 12], 
                              [67, 9], [75, 9], [85, 1], [55, 18.5]];
            
            const labels = ['F', 'Pc', 'U1', 'Ba', 'Bs', 'S1', 'U2', 'O1', 'S2', 'U3', 'O2', 'S3', 
                           'Ph', 'O3', 'T', 'Td', 'R', 'Q', 'S/N/L'];
            
            const annotations = [];
            for (let i = 0; i < Math.min(locations.length, labels.length); i++) {
                const [x, y] = locations[i];
                if (x >= 30 && x <= 90 && y >= 0 && y <= 20) {
                    annotations.push({
                        x: x, y: y, text: labels[i], showarrow: false,
                        font: { size: 9, color: 'grey' },
                        bgcolor: 'rgba(255,255,255,0.8)', bordercolor: 'grey', borderwidth: 1
                    });
                }
            }
            layout.annotations = annotations;

            Plotly.newPlot('plotDiv', traces, layout);
            document.getElementById('plotContainer').style.display = 'block';
            document.getElementById('downloadSection').style.display = 'block'; // æ˜¾ç¤ºä¸‹è½½åŒºåŸŸ
            showAlert('TAS å›¾è¡¨ç”ŸæˆæˆåŠŸï¼', 'success');
        }

        // Harker å›¾è¡¨ç”Ÿæˆ - æ­£æ–¹å½¢å­å›¾å¸ƒå±€
        function generateHarkerPlot() {
            const requiredCols = ['SiO2'];
            const missingCols = requiredCols.filter(col => !globalData[0].hasOwnProperty(col));
            if (missingCols.length > 0) {
                showAlert('ç¼ºå°‘å¿…éœ€çš„åˆ—ï¼šSiO2', 'error');
                return;
            }

            // å®šä¹‰ä¸ SiO2 ä½œå›¾çš„æ°§åŒ–ç‰© - ç²¾ç¡®æŒ‰ç…§ run.py Harker.py
            const oxides = ['Al2O3', 'Fe2O3', 'MgO', 'CaO', 'Na2O', 'K2O', 'TiO2', 'P2O5'];
            const availableOxides = oxides.filter(ox => globalData[0].hasOwnProperty(ox));
            
            if (availableOxides.length === 0) {
                showAlert('æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„æ°§åŒ–ç‰©æ•°æ®æ¥ä¸ SiO2 ä½œå›¾\néœ€è¦: Al2O3, Fe2O3, MgO, CaO, Na2O, K2O, TiO2, P2O5', 'error');
                return;
            }

            const traces = [];
            const colorMapping = getColorMapping();
            const classificationCol = getClassificationColumn();
            
            // ä¸ºæ¯ä¸ªå¯ç”¨æ°§åŒ–ç‰©åˆ›å»ºå­å›¾
            availableOxides.forEach((oxide, subplotIndex) => {
                if (classificationCol) {
                    // æœ‰åˆ†ç±»åˆ—ï¼ŒæŒ‰åˆ†ç±»ç»˜åˆ¶
                    const groups = {};
                    globalData.forEach((row, i) => {
                        const groupValue = row[classificationCol] || 'Unknown';
                        const sio2_val = parseFloat(row.SiO2);
                        const oxide_val = parseFloat(row[oxide]);
                        
                        if (!isNaN(sio2_val) && !isNaN(oxide_val)) {
                            if (!groups[groupValue]) {
                                groups[groupValue] = { x: [], y: [] };
                            }
                            groups[groupValue].x.push(sio2_val);
                            groups[groupValue].y.push(oxide_val);
                        }
                    });
                    
                    // ä¸ºæ¯ä¸ªåˆ†ç»„åˆ›å»º trace
                    Object.keys(groups).forEach((groupName) => {
                        const group = groups[groupName];
                        const color = colorMapping.legendItems.find(item => item.label === groupName)?.color || '#1f77b4';
                        
                        traces.push({
                            x: group.x,
                            y: group.y,
                            mode: 'markers',
                            type: 'scatter',
                            name: groupName,
                            legendgroup: `group_${groupName}`,
                            marker: { 
                                size: 6, 
                                color: color,
                                opacity: 0.7,
                                line: { color: 'black', width: 0.5 }
                            },
                            showlegend: subplotIndex === 0,  // åªåœ¨ç¬¬ä¸€ä¸ªå­å›¾æ˜¾ç¤ºå›¾ä¾‹
                            xaxis: `x${subplotIndex + 1}`,
                            yaxis: `y${subplotIndex + 1}`
                        });
                    });
                } else {
                    // æ²¡æœ‰åˆ†ç±»åˆ—ï¼ŒæŒ‰æ ·å“ç¼–å·ç»˜åˆ¶
                    globalData.forEach((row, sampleIndex) => {
                        const sio2_val = parseFloat(row.SiO2);
                        const oxide_val = parseFloat(row[oxide]);
                        
                        if (!isNaN(sio2_val) && !isNaN(oxide_val)) {
                            traces.push({
                                x: [sio2_val], 
                                y: [oxide_val],
                                mode: 'markers', 
                                type: 'scatter',
                                name: colorMapping.labels[sampleIndex],
                                legendgroup: `sample_${sampleIndex}`,
                                marker: { 
                                    size: 6, 
                                    color: colorMapping.colors[sampleIndex],
                                    opacity: 0.7,
                                    line: { color: 'black', width: 0.5 }
                                },
                                showlegend: subplotIndex === 0,  // åªåœ¨ç¬¬ä¸€ä¸ªå­å›¾æ˜¾ç¤ºå›¾ä¾‹
                                xaxis: `x${subplotIndex + 1}`,
                                yaxis: `y${subplotIndex + 1}`
                            });
                        }
                    });
                }
            });

            // åˆ›å»º4Ã—2å¸ƒå±€ - ä½¿ç”¨Plotlyçš„subplotsåŠŸèƒ½ï¼Œç¡®ä¿æ¯ä¸ªå­å›¾éƒ½æ˜¯1:1æ­£æ–¹å½¢
            const numSubplots = availableOxides.length;
            const cols = 2; // å›ºå®š2åˆ—
            const rows = Math.ceil(numSubplots / cols); // æ ¹æ®æ°§åŒ–ç‰©æ•°é‡è®¡ç®—è¡Œæ•°
            
            // åŸºç¡€å¸ƒå±€ - æ•´ä½“æ˜¯2:1ï¼ˆé«˜:å®½ï¼‰æ¯”ä¾‹ï¼Œä½¿ç”¨subplot gridï¼Œå¢åŠ å‚ç›´é—´è·é¿å…é‡å 
            const layout = {
                title: `Harker Variation Diagrams (${availableOxides.length} oxides vs SiO2) - 4Ã—2 Layout`,
                width: 1000,
                height: 1600, // å¢åŠ é«˜åº¦ä»¥é€‚åº”æ›´å¤§çš„å‚ç›´é—´è·
                showlegend: true,
                grid: {
                    rows: rows,
                    columns: cols,
                    pattern: 'independent',
                    xgap: 0.15,  // æ°´å¹³é—´è·
                    ygap: 0.2    // å¢å¤§å‚ç›´é—´è·é¿å…SiO2æ ‡ç­¾é‡å 
                }
            };

            // ä¸ºæ¯ä¸ªå­å›¾è®¾ç½®ç‹¬ç«‹çš„è½´ï¼Œç¡®ä¿æ¯ä¸ªå­å›¾æ˜¯æ­£æ–¹å½¢ï¼Œä½†ä¸æ˜¾ç¤ºç½‘æ ¼çº¿
            availableOxides.forEach((oxide, i) => {
                const axisIndex = i + 1;
                const xAxisKey = axisIndex === 1 ? 'xaxis' : `xaxis${axisIndex}`;
                const yAxisKey = axisIndex === 1 ? 'yaxis' : `yaxis${axisIndex}`;
                
                layout[xAxisKey] = {
                    title: 'SiOâ‚‚ (wt%)',
                    showgrid: false,      // ä¸æ˜¾ç¤ºç½‘æ ¼çº¿
                    showline: true,       // æ˜¾ç¤ºåæ ‡è½´çº¿
                    linecolor: 'black',   // è½´çº¿é¢œè‰²
                    linewidth: 1,         // è½´çº¿å®½åº¦
                    zeroline: false,
                    showticklabels: true,
                    tickfont: { size: 10 },
                    titlefont: { size: 12 },
                    ticks: 'outside',     // åˆ»åº¦åœ¨å¤–ä¾§
                    tickcolor: 'black',   // åˆ»åº¦çº¿é¢œè‰²
                    mirror: true          // æ˜¾ç¤ºå¯¹è¾¹è½´çº¿
                };
                
                layout[yAxisKey] = {
                    title: `${oxide} (wt%)`,
                    showgrid: false,      // ä¸æ˜¾ç¤ºç½‘æ ¼çº¿
                    showline: true,       // æ˜¾ç¤ºåæ ‡è½´çº¿
                    linecolor: 'black',   // è½´çº¿é¢œè‰²
                    linewidth: 1,         // è½´çº¿å®½åº¦
                    zeroline: false,
                    showticklabels: true,
                    tickfont: { size: 10 },
                    titlefont: { size: 12 },
                    ticks: 'outside',     // åˆ»åº¦åœ¨å¤–ä¾§
                    tickcolor: 'black',   // åˆ»åº¦çº¿é¢œè‰²
                    mirror: true,         // æ˜¾ç¤ºå¯¹è¾¹è½´çº¿
                    scaleanchor: xAxisKey, // ç¡®ä¿ä¸å¯¹åº”xè½´ä¿æŒ1:1æ¯”ä¾‹ï¼Œè®©å­å›¾æ˜¯æ­£æ–¹å½¢
                    scaleratio: 1          // å¼ºåˆ¶1:1æ¯”ä¾‹
                };
            });

            Plotly.newPlot('plotDiv', traces, layout);
            document.getElementById('plotContainer').style.display = 'block';
            document.getElementById('downloadSection').style.display = 'block'; // æ˜¾ç¤ºä¸‹è½½åŒºåŸŸ
            showAlert(`Harker å˜å¼‚å›¾ç”ŸæˆæˆåŠŸï¼åŒ…å« ${availableOxides.length} ä¸ªå­å›¾`, 'success');
        }

        // REE å›¾è¡¨ç”Ÿæˆ - ä¸¥æ ¼æŒ‰ç…§ run.py ä¸­ REE.py çš„å®ç°
        function generateREEPlot() {
            const standard = document.getElementById('reeStandard').value;
            // REE å…ƒç´ çš„ç²¾ç¡®é¡ºåºæ¥è‡ª REE.py
            const reeElements = ['La', 'Ce', 'Pr', 'Nd', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu'];
            const availableREEs = reeElements.filter(el => globalData[0].hasOwnProperty(el));
            
            if (availableREEs.length === 0) {
                showAlert('æ²¡æœ‰æ‰¾åˆ° REE æ•°æ®\néœ€è¦: La, Ce, Pr, Nd, Sm, Eu, Gd, Tb, Dy, Ho, Er, Tm, Yb, Lu', 'error');
                return;
            }

            const normValues = standards.ree[standard];
            let y_bottom = Infinity, y_top = -Infinity;
            const colorMapping = getColorMapping();
            const classificationCol = getClassificationColumn();
            
            let traces = [];
            
            if (classificationCol) {
                // æœ‰åˆ†ç±»åˆ—ï¼ŒæŒ‰åˆ†ç±»ç»˜åˆ¶
                const groups = {};
                globalData.forEach((row, i) => {
                    const groupValue = row[classificationCol] || 'Unknown';
                    if (!groups[groupValue]) {
                        groups[groupValue] = { samples: [] };
                    }
                    groups[groupValue].samples.push({ row, index: i });
                });
                
                Object.keys(groups).forEach((groupName) => {
                    const group = groups[groupName];
                    const color = colorMapping.legendItems.find(item => item.label === groupName)?.color || '#1f77b4';
                    
                    group.samples.forEach((sample) => {
                        const { row, index } = sample;
                        const x = [], y = [];
                        
                        availableREEs.forEach((el, j) => {
                            const value = parseFloat(row[el]);
                            if (!isNaN(value) && value > 0 && normValues[el]) {
                                const normalized_value = value / normValues[el];
                                const log_value = Math.log10(normalized_value);
                                
                                x.push(j + 1);  // X ä½ç½®ä» 1 å¼€å§‹
                                y.push(log_value);
                                
                                // è·Ÿè¸ª Y èŒƒå›´
                                if (log_value < y_bottom) y_bottom = log_value;
                                if (log_value > y_top) y_top = log_value;
                            }
                        });
                        
                        traces.push({
                            x: x, y: y, mode: 'lines+markers', type: 'scatter',
                            name: groupName,
                            legendgroup: `group_${groupName}`,
                            showlegend: index === group.samples[0].index, // åªåœ¨ç¬¬ä¸€ä¸ªæ ·å“æ˜¾ç¤ºå›¾ä¾‹ï¼ŒæŒ‰Labelåˆ†ç»„
                            line: { color: color, width: 1.5 },
                            marker: { color: color, size: 6 }
                        });
                    });
                });
            } else {
                // æ²¡æœ‰åˆ†ç±»åˆ—ï¼ŒæŒ‰æ ·å“ç¼–å·ç»˜åˆ¶
                traces = globalData.map((row, i) => {
                    const x = [], y = [];
                    availableREEs.forEach((el, j) => {
                        const value = parseFloat(row[el]);
                        if (!isNaN(value) && value > 0 && normValues[el]) {
                            const normalized_value = value / normValues[el];
                            const log_value = Math.log10(normalized_value);
                            
                            x.push(j + 1);  // X ä½ç½®ä» 1 å¼€å§‹
                            y.push(log_value);
                            
                            // è·Ÿè¸ª Y èŒƒå›´
                            if (log_value < y_bottom) y_bottom = log_value;
                            if (log_value > y_top) y_top = log_value;
                        }
                    });
                    
                    return {
                        x: x, y: y, mode: 'lines+markers', type: 'scatter',
                        name: colorMapping.labels[i],
                        line: { color: colorMapping.colors[i], width: 1.5 },
                        marker: { color: colorMapping.colors[i], size: 6 }
                    };
                });
            }

            // è®¾ç½®é€‚å½“çš„è½´èŒƒå›´å’Œåˆ»åº¦æŒ‰ç…§ REE.py
            const xticks = availableREEs.map((_, i) => i + 1);
            
            const layout = {
                title: 'REE Standardized Pattern Diagram',
                width: 900,
                height: 600,
                xaxis: { 
                    title: 'REE Standardized Pattern', 
                    tickvals: xticks,
                    ticktext: availableREEs,
                    tickangle: 45
                },
                yaxis: { 
                    title: `Sample/${standard.split(" ")[0]}`,
                    range: y_bottom !== Infinity ? [y_bottom - (y_top - y_bottom) * 0.1, y_top + (y_top - y_bottom) * 0.1] : [-2, 2],
                    tickvals: [-2, -1, 0, 1, 2],
                    ticktext: ['0.01', '0.1', '1', '10', '100']
                },
                showlegend: true
            };

            Plotly.newPlot('plotDiv', traces, layout);
            document.getElementById('plotContainer').style.display = 'block';
            document.getElementById('downloadSection').style.display = 'block'; // æ˜¾ç¤ºä¸‹è½½åŒºåŸŸ
            showAlert(`REE å›¾è¡¨ç”ŸæˆæˆåŠŸï¼åŒ…å« ${availableREEs.length} ä¸ªå…ƒç´ `, 'success');
        }

        // Trace å…ƒç´ è››ç½‘å›¾ç”Ÿæˆ - ä¸¥æ ¼æŒ‰ç…§ run.py ä¸­ Trace.py çš„å®ç°
        function generateTracePlot() {
            const standard = document.getElementById('traceStandard').value;
            const elementSet = document.getElementById('elementSet').value;
            const elements = elementSets[elementSet];
            
            // æ‰¾åˆ°å¯ç”¨å…ƒç´ ï¼ŒåŒ…æ‹¬ K2O åˆ° K å’Œ TiO2 åˆ° Ti çš„è½¬æ¢
            const availableElements = elements.filter(el => {
                return globalData[0].hasOwnProperty(el) || 
                       (el === 'K' && globalData[0].hasOwnProperty('K2O')) ||
                       (el === 'Ti' && globalData[0].hasOwnProperty('TiO2'));
            });
            
            if (availableElements.length === 0) {
                const element_set_name = elementSet === 'cs_lu' ? 'Cs-Lu (36 å…ƒç´ )' : 'Rb-Lu (26 å…ƒç´ )';
                showAlert(`æ²¡æœ‰æ‰¾åˆ°å¾®é‡å…ƒç´ æ•°æ®\néœ€è¦æ¥è‡ª ${element_set_name} åºåˆ—çš„å…ƒç´ `, 'error');
                return;
            }

            const normValues = standards.trace[standard];
            let y_bottom = Infinity, y_top = -Infinity;
            const colorMapping = getColorMapping();
            const classificationCol = getClassificationColumn();
            
            let traces = [];
            
            if (classificationCol) {
                // æœ‰åˆ†ç±»åˆ—ï¼ŒæŒ‰åˆ†ç±»ç»˜åˆ¶
                const groups = {};
                globalData.forEach((row, i) => {
                    const groupValue = row[classificationCol] || 'Unknown';
                    if (!groups[groupValue]) {
                        groups[groupValue] = { samples: [] };
                    }
                    groups[groupValue].samples.push({ row, index: i });
                });
                
                Object.keys(groups).forEach((groupName) => {
                    const group = groups[groupName];
                    const color = colorMapping.legendItems.find(item => item.label === groupName)?.color || '#1f77b4';
                    
                    group.samples.forEach((sample) => {
                        const { row, index } = sample;
                        const x = [], y = [];
                        
                        availableElements.forEach((el, j) => {
                            if (normValues[el]) {
                                // è·å–åŸå§‹å€¼ï¼ŒåŒ…æ‹¬è½¬æ¢
                                let raw_value;
                                if (row[el] && !isNaN(parseFloat(row[el])) && parseFloat(row[el]) > 0) {
                                    raw_value = parseFloat(row[el]);
                                } else if (el === 'K' && row['K2O'] && !isNaN(parseFloat(row['K2O']))) {
                                    // ä» K2O è½¬æ¢åˆ° Kï¼ˆæ¥è‡ª Trace.pyï¼‰
                                    raw_value = parseFloat(row['K2O']) * (2 * 39.0983 / 94.1956) * 10000;
                                } else if (el === 'Ti' && row['TiO2'] && !isNaN(parseFloat(row['TiO2']))) {
                                    // ä» TiO2 è½¬æ¢åˆ° Tiï¼ˆæ¥è‡ª Trace.pyï¼‰
                                    raw_value = parseFloat(row['TiO2']) * (47.867 / 79.865) * 10000;
                                } else {
                                    return;
                                }
                                
                                try {
                                    const normalized_value = raw_value / normValues[el];
                                    const log_value = Math.log10(normalized_value);
                                    
                                    x.push(j + 1);  // X ä½ç½®ä» 1 å¼€å§‹
                                    y.push(log_value);
                                    
                                    // è·Ÿè¸ª Y èŒƒå›´
                                    if (log_value < y_bottom) y_bottom = log_value;
                                    if (log_value > y_top) y_top = log_value;
                                } catch (error) {
                                    // å¿½ç•¥é”™è¯¯
                                }
                            }
                        });
                        
                        traces.push({
                            x: x, y: y, mode: 'lines+markers', type: 'scatter',
                            name: groupName,
                            legendgroup: `group_${groupName}`,
                            showlegend: index === group.samples[0].index, // åªåœ¨ç¬¬ä¸€ä¸ªæ ·å“æ˜¾ç¤ºå›¾ä¾‹ï¼ŒæŒ‰Labelåˆ†ç»„
                            line: { color: color, width: 1.5 },
                            marker: { color: color, size: 6 }
                        });
                    });
                });
            } else {
                // æ²¡æœ‰åˆ†ç±»åˆ—ï¼ŒæŒ‰æ ·å“ç¼–å·ç»˜åˆ¶
                traces = globalData.map((row, i) => {
                    const x = [], y = [];
                    availableElements.forEach((el, j) => {
                        if (normValues[el]) {
                            // è·å–åŸå§‹å€¼ï¼ŒåŒ…æ‹¬è½¬æ¢
                            let raw_value;
                            if (row[el] && !isNaN(parseFloat(row[el])) && parseFloat(row[el]) > 0) {
                                raw_value = parseFloat(row[el]);
                            } else if (el === 'K' && row['K2O'] && !isNaN(parseFloat(row['K2O']))) {
                                // ä» K2O è½¬æ¢åˆ° Kï¼ˆæ¥è‡ª Trace.pyï¼‰
                                raw_value = parseFloat(row['K2O']) * (2 * 39.0983 / 94.1956) * 10000;
                            } else if (el === 'Ti' && row['TiO2'] && !isNaN(parseFloat(row['TiO2']))) {
                                // ä» TiO2 è½¬æ¢åˆ° Tiï¼ˆæ¥è‡ª Trace.pyï¼‰
                                raw_value = parseFloat(row['TiO2']) * (47.867 / 79.865) * 10000;
                            } else {
                                return;
                            }
                            
                            try {
                                const normalized_value = raw_value / normValues[el];
                                const log_value = Math.log10(normalized_value);
                                
                                x.push(j + 1);  // X ä½ç½®ä» 1 å¼€å§‹
                                y.push(log_value);
                                
                                // è·Ÿè¸ª Y èŒƒå›´
                                if (log_value < y_bottom) y_bottom = log_value;
                                if (log_value > y_top) y_top = log_value;
                            } catch (error) {
                                // å¿½ç•¥é”™è¯¯
                            }
                        }
                    });
                    
                    return {
                        x: x, y: y, mode: 'lines+markers', type: 'scatter',
                        name: colorMapping.labels[i],
                        line: { color: colorMapping.colors[i], width: 1.5 },
                        marker: { color: colorMapping.colors[i], size: 6 }
                    };
                });
            }

            // è®¾ç½®é€‚å½“çš„è½´èŒƒå›´å’Œåˆ»åº¦
            const xticks = availableElements.map((_, i) => i + 1);
            const element_set_name = elementSet === 'cs_lu' ? 'Cs-Lu (36 Elements)' : 'Rb-Lu (26 Elements)';
            
            const layout = {
                title: `Trace Element Standardized Pattern Diagram\n${element_set_name} - ${availableElements.length} Elements Available`,
                width: 1000,
                height: 600,
                xaxis: { 
                    title: 'Trace Elements Standardized Pattern',
                    tickvals: xticks,
                    ticktext: availableElements,
                    tickangle: -45
                },
                yaxis: { 
                    title: `Sample/${standard}`,
                    range: y_bottom !== Infinity ? [y_bottom - (y_top - y_bottom) * 0.1, y_top + (y_top - y_bottom) * 0.1] : [-2, 2],
                    tickvals: [-2, -1, 0, 1, 2],
                    ticktext: ['0.01', '0.1', '1', '10', '100']
                },
                showlegend: true
            };

            // æ·»åŠ ç»¼åˆå‚è€ƒä¿¡æ¯
            const reference_map = {
                'PM': 'Sun, S.S. & McDonough, W.F. (1989)',
                'OIB': 'Sun, S.S. & McDonough, W.F. (1989)', 
                'EMORB': 'Sun, S.S. & McDonough, W.F. (1989)',
                'C1': 'Sun, S.S. & McDonough, W.F. (1989)',
                'NMORB': 'Sun, S.S. & McDonough, W.F. (1989)',
                'UCC_Rudnick & Gao2003': 'Rudnick, R.L. & Gao, S. (2003)'
            };
            
            layout.annotations = [{
                x: 0.02, y: 0.98, 
                text: `Standard: ${standard} (${reference_map[standard] || ''})\nElements: ${availableElements.length} of ${element_set_name}`,
                showarrow: false, xref: 'paper', yref: 'paper',
                font: {size: 8}, bgcolor: 'white', bordercolor: 'grey'
            }];

            Plotly.newPlot('plotDiv', traces, layout);
            document.getElementById('plotContainer').style.display = 'block';
            document.getElementById('downloadSection').style.display = 'block'; // æ˜¾ç¤ºä¸‹è½½åŒºåŸŸ
            showAlert(`å¾®é‡å…ƒç´ å›¾è¡¨ç”ŸæˆæˆåŠŸï¼åŒ…å« ${availableElements.length} ä¸ªå…ƒç´ `, 'success');
        }

        // Pearce å›¾è¡¨ç”Ÿæˆ - ä¸¥æ ¼æŒ‰ç…§ run.py ä¸­ Pearce.py çš„å®ç°
        function generatePearcePlot() {
            const requiredCols = ['Rb', 'Y', 'Nb', 'Yb', 'Ta'];
            const missingCols = requiredCols.filter(col => !globalData[0].hasOwnProperty(col));
            if (missingCols.length > 0) {
                showAlert(`ç¼ºå°‘å¿…éœ€çš„åˆ—ï¼š${missingCols.join(', ')}\néœ€è¦: Rb, Y, Nb, Yb, Ta (ppm)`, 'error');
                return;
            }

            // ç²¾ç¡®çš„å››ä¸ªæ¡ä»¶æ¥è‡ª Pearce.py
            const conditions = [
                {
                    BaseLines: [[[2, 80], [55, 300]], [[55, 300], [400, 2000]], [[55, 300], [51.5, 8]], 
                               [[51.5, 8], [50, 1]], [[51.5, 8], [2000, 400]]],
                    xLabel: 'Y+Nb (ppm)', yLabel: 'Rb (ppm)',
                    Labels: ['syn-COLG', 'VAG', 'WPG', 'ORG'],
                    Locations: [[1, 3], [1, 1], [2.4, 2.4], [3, 1]],
                    xlim: [0.3, 3.2], ylim: [0, 3.2],
                    xticks: [1, 2, 3], xticklabels: [10, 100, 1000],
                    yticks: [0, 1, 2, 3], yticklabels: [1, 10, 100, 1000]
                },
                {
                    BaseLines: [[[0.5, 140], [6, 200]], [[6, 200], [50, 2000]], [[6, 200], [6, 8]], 
                               [[6, 8], [6, 1]], [[6, 8], [200, 400]]],
                    xLabel: 'Yb+Ta (ppm)', yLabel: 'Rb (ppm)',
                    Labels: ['syn-COLG', 'VAG', 'WPG', 'ORG'],
                    Locations: [[0.5, 3], [0.5, 1], [1.5, 2.4], [2, 1]],
                    xlim: [-0.2, 2.5], ylim: [0, 3.2],
                    xticks: [0, 1, 2], xticklabels: [1, 10, 100],
                    yticks: [0, 1, 2, 3], yticklabels: [1, 10, 100, 1000]
                },
                {
                    BaseLines: [[[1, 2000], [50, 10]], [[40, 1], [50, 10]], [[50, 10], [1000, 100]], 
                               [[25, 25], [1000, 400]]],
                    xLabel: 'Y (ppm)', yLabel: 'Nb (ppm)',
                    Labels: ['syn-COLG', 'VAG', 'WPG', 'ORG'],
                    Locations: [[0.5, 1.5], [0.5, 2], [2, 2], [2.2, 0.5]],
                    xlim: [0, 3.2], ylim: [0, 3.2],
                    xticks: [0, 1, 2, 3], xticklabels: [1, 10, 100, 1000],
                    yticks: [0, 1, 2, 3], yticklabels: [1, 10, 100, 1000]
                },
                {
                    BaseLines: [[[0.55, 20], [3, 2]], [[0.1, 0.35], [3, 2]], [[3, 2], [5, 1]], 
                               [[5, 0.05], [5, 1]], [[5, 1], [100, 7]], [[3, 2], [100, 20]]],
                    xLabel: 'Yb (ppm)', yLabel: 'Ta (ppm)',
                    Labels: ['syn-COLG', 'VAG', 'WPG', 'ORG'],
                    Locations: [[-0.5, 0.1], [-0.5, -1], [0.7, 1], [1.5, 0]],
                    xlim: [-1, 2], ylim: [-1.2, 2],
                    xticks: [-1, 0, 1, 2], xticklabels: [0.1, 1, 10, 100],
                    yticks: [-1, 0, 1, 2], yticklabels: [0.1, 1, 10, 100]
                }
            ];

            // è®¡ç®—æ•°æ®å€¼
            const colorMapping = getColorMapping();
            const classificationCol = getClassificationColumn();
            const plot_data = [];
            
            globalData.forEach((row, i) => {
                plot_data.push({
                    xa: parseFloat(row.Y) + parseFloat(row.Nb),    // Y+Nb vs Rb
                    ya: parseFloat(row.Rb),
                    xb: parseFloat(row.Yb) + parseFloat(row.Ta),   // Yb+Ta vs Rb  
                    yb: parseFloat(row.Rb),
                    xc: parseFloat(row.Y),                // Y vs Nb
                    yc: parseFloat(row.Nb),
                    xd: parseFloat(row.Yb),               // Yb vs Ta
                    yd: parseFloat(row.Ta),
                    label: classificationCol ? (row[classificationCol] || 'Unknown') : colorMapping.labels[i],
                    color: colorMapping.colors[i],
                    groupValue: classificationCol ? (row[classificationCol] || 'Unknown') : `Sample_${i}`
                });
            });

            // åˆ›å»ºå››ä¸ªå­å›¾çš„è¿¹è¸ª
            const traces = [];
            const data_keys = [['xa', 'ya'], ['xb', 'yb'], ['xc', 'yc'], ['xd', 'yd']];
            
            data_keys.forEach((keys, diagram_idx) => {
                const [x_key, y_key] = keys;
                const condition = conditions[diagram_idx];
                
                // ç»˜åˆ¶è¾¹ç•Œçº¿
                condition.BaseLines.forEach(line => {
                    const x_coords = line.map(point => Math.log10(point[0]));
                    const y_coords = line.map(point => Math.log10(point[1]));
                    
                    // ç‰¹æ®Šæ ·å¼å¤„ç†
                    let lineStyle = { color: 'black', width: 0.8 };
                    if (diagram_idx === 2 && JSON.stringify(line) === JSON.stringify([[25, 25], [1000, 400]])) {
                        lineStyle = { color: 'grey', width: 0.8, dash: 'dot' };
                    } else if (diagram_idx === 3 && JSON.stringify(line) === JSON.stringify([[3, 2], [100, 20]])) {
                        lineStyle = { color: 'grey', width: 0.8, dash: 'dot' };
                    }
                    
                    traces.push({
                        x: x_coords, y: y_coords, mode: 'lines', type: 'scatter',
                        line: lineStyle, showlegend: false,
                        xaxis: `x${diagram_idx + 1}`, yaxis: `y${diagram_idx + 1}`
                    });
                });
                
                // ç»˜åˆ¶æ•°æ®ç‚¹
                if (classificationCol) {
                    // æœ‰åˆ†ç±»åˆ—ï¼ŒæŒ‰åˆ†ç±»ç»˜åˆ¶
                    const groups = {};
                    plot_data.forEach((data, i) => {
                        const groupValue = data.groupValue;
                        if (!groups[groupValue]) {
                            groups[groupValue] = [];
                        }
                        groups[groupValue].push(data);
                    });
                    
                    Object.keys(groups).forEach((groupName) => {
                        const groupData = groups[groupName];
                        const color = colorMapping.legendItems.find(item => item.label === groupName)?.color || '#1f77b4';
                        
                        const x_vals = [];
                        const y_vals = [];
                        
                        groupData.forEach((data) => {
                            const x_val = data[x_key];
                            const y_val = data[y_key];
                            
                            if (x_val > 0 && y_val > 0) {  // åªç»˜åˆ¶æ­£å€¼ï¼ˆç”¨äºå¯¹æ•°åˆ»åº¦ï¼‰
                                x_vals.push(Math.log10(x_val));
                                y_vals.push(Math.log10(y_val));
                            }
                        });
                        
                        if (x_vals.length > 0) {
                            traces.push({
                                x: x_vals, 
                                y: y_vals,
                                mode: 'markers', 
                                type: 'scatter',
                                name: groupName,
                                legendgroup: `group_${groupName}`,
                                marker: { size: 8, color: color, opacity: 0.8 },
                                showlegend: diagram_idx === 0,  // åªåœ¨ç¬¬ä¸€ä¸ªå›¾ä¸Šæ˜¾ç¤ºå›¾ä¾‹
                                xaxis: `x${diagram_idx + 1}`, 
                                yaxis: `y${diagram_idx + 1}`
                            });
                        }
                    });
                } else {
                    // æ²¡æœ‰åˆ†ç±»åˆ—ï¼ŒæŒ‰æ ·å“ç¼–å·ç»˜åˆ¶
                    plot_data.forEach((data, i) => {
                        const x_val = data[x_key];
                        const y_val = data[y_key];
                        
                        if (x_val > 0 && y_val > 0) {  // åªç»˜åˆ¶æ­£å€¼ï¼ˆç”¨äºå¯¹æ•°åˆ»åº¦ï¼‰
                            traces.push({
                                x: [Math.log10(x_val)], 
                                y: [Math.log10(y_val)],
                                mode: 'markers', 
                                type: 'scatter',
                                name: data.label,
                                marker: { size: 8, color: data.color, opacity: 0.8 },
                                showlegend: diagram_idx === 0 && globalData.length <= 10,  // åªåœ¨ç¬¬ä¸€ä¸ªå›¾ä¸Šæ˜¾ç¤ºå›¾ä¾‹
                                xaxis: `x${diagram_idx + 1}`, 
                                yaxis: `y${diagram_idx + 1}`
                            });
                        }
                    });
                }
                
                // æ·»åŠ å­—æ®µæ ‡ç­¾
                condition.Labels.forEach((label, i) => {
                    const location = condition.Locations[i];
                    traces.push({
                        x: [location[0]], y: [location[1]],
                        mode: 'text', type: 'scatter',
                        text: [label], textposition: 'middle center',
                        textfont: { size: 9, color: 'grey' },
                        showlegend: false,
                        xaxis: `x${diagram_idx + 1}`, yaxis: `y${diagram_idx + 1}`
                    });
                });
            });

            // ä¸ºæ¯ä¸ªå­å›¾æ·»åŠ å¤–æ¡†
            conditions.forEach((condition, diagram_idx) => {
                const xlim = condition.xlim;
                const ylim = condition.ylim;
                
                // åˆ›å»ºçŸ©å½¢å¤–æ¡†ï¼ˆå³ä¸Šè§’é¡ºæ—¶é’ˆç»˜åˆ¶ï¼‰
                const frameX = [xlim[0], xlim[1], xlim[1], xlim[0], xlim[0]];
                const frameY = [ylim[0], ylim[0], ylim[1], ylim[1], ylim[0]];
                
                traces.push({
                    x: frameX,
                    y: frameY,
                    mode: 'lines',
                    type: 'scatter',
                    line: { 
                        color: 'black', 
                        width: 1.5 
                    },
                    showlegend: false,
                    hoverinfo: 'skip',
                    xaxis: `x${diagram_idx + 1}`,
                    yaxis: `y${diagram_idx + 1}`
                });
            });

            const layout = {
                title: 'Pearce Diagrams for Granite Discrimination (Pearce et al., 1984)',
                width: 1000,
                height: 900,  // å¢åŠ é«˜åº¦ä»¥é€‚åº”åº•éƒ¨æ³¨é‡Š
                margin: { l: 80, r: 50, t: 80, b: 120 },  // å¢åŠ åº•éƒ¨è¾¹è·ç»™æ³¨é‡Šç•™å‡ºç©ºé—´
                grid: { rows: 2, columns: 2, pattern: 'independent' },
                // ç¬¬ä¸€ä¸ªå­å›¾ (å·¦ä¸Š)
                xaxis: { 
                    title: conditions[0].xLabel, 
                    domain: [0, 0.45], 
                    range: conditions[0].xlim,
                    showline: false,        // ä¸æ˜¾ç¤ºåæ ‡è½´çº¿
                    showticklabels: true,
                    ticks: '',              // ä¸æ˜¾ç¤ºåˆ»åº¦çº¿
                    showgrid: false,        // ä¸æ˜¾ç¤ºç½‘æ ¼
                    zeroline: false         // ä¸æ˜¾ç¤ºé›¶çº¿
                },
                yaxis: { 
                    title: conditions[0].yLabel, 
                    domain: [0.55, 1], 
                    range: conditions[0].ylim,
                    showline: false,        // ä¸æ˜¾ç¤ºåæ ‡è½´çº¿
                    showticklabels: true,
                    ticks: '',              // ä¸æ˜¾ç¤ºåˆ»åº¦çº¿
                    showgrid: false,        // ä¸æ˜¾ç¤ºç½‘æ ¼
                    zeroline: false         // ä¸æ˜¾ç¤ºé›¶çº¿
                },
                // ç¬¬äºŒä¸ªå­å›¾ (å³ä¸Š)
                xaxis2: { 
                    title: conditions[1].xLabel, 
                    domain: [0.55, 1], 
                    range: conditions[1].xlim,
                    showline: false,
                    showticklabels: true,
                    ticks: '',
                    showgrid: false,
                    zeroline: false
                },
                yaxis2: { 
                    title: conditions[1].yLabel, 
                    domain: [0.55, 1], 
                    range: conditions[1].ylim,
                    showline: false,
                    showticklabels: true,
                    ticks: '',
                    showgrid: false,
                    zeroline: false
                },
                // ç¬¬ä¸‰ä¸ªå­å›¾ (å·¦ä¸‹)
                xaxis3: { 
                    title: conditions[2].xLabel, 
                    domain: [0, 0.45], 
                    range: conditions[2].xlim,
                    showline: false,
                    showticklabels: true,
                    ticks: '',
                    showgrid: false,
                    zeroline: false
                },
                yaxis3: { 
                    title: conditions[2].yLabel, 
                    domain: [0, 0.45], 
                    range: conditions[2].ylim,
                    showline: false,
                    showticklabels: true,
                    ticks: '',
                    showgrid: false,
                    zeroline: false
                },
                // ç¬¬å››ä¸ªå­å›¾ (å³ä¸‹)
                xaxis4: { 
                    title: conditions[3].xLabel, 
                    domain: [0.55, 1], 
                    range: conditions[3].xlim,
                    showline: false,
                    showticklabels: true,
                    ticks: '',
                    showgrid: false,
                    zeroline: false
                },
                yaxis4: { 
                    title: conditions[3].yLabel, 
                    domain: [0, 0.45], 
                    range: conditions[3].ylim,
                    showline: false,
                    showticklabels: true,
                    ticks: '',
                    showgrid: false,
                    zeroline: false
                },
                annotations: [
                    // å°†è¯´æ˜æ–‡å­—ç§»åˆ°æ•´ä¸ªå¯è§†åŒ–åŒºåŸŸçš„æœ€åº•éƒ¨ï¼Œé¿å…ä¸å›¾è¡¨å’Œåæ ‡è½´é‡å 
                    { 
                        x: 0.5, 
                        y: -0.12, 
                        text: 'syn-COLG: syn-collision granites, VAG: volcanic arc granites<br>WPG: within plate granites, ORG: ocean ridge granites',
                        showarrow: false, 
                        xref: 'paper', 
                        yref: 'paper', 
                        font: { size: 10 },
                        xanchor: 'center',
                        yanchor: 'top'
                    },
                    { 
                        x: 0.5, 
                        y: -0.18, 
                        text: 'Reference: Pearce, J.A. et al. (1984) J. Petrology, v.25, p.956-983',
                        showarrow: false, 
                        xref: 'paper', 
                        yref: 'paper', 
                        font: { size: 8 },
                        xanchor: 'center',
                        yanchor: 'top'
                    }
                ]
            };

            Plotly.newPlot('plotDiv', traces, layout);
            document.getElementById('plotContainer').style.display = 'block';
            document.getElementById('downloadSection').style.display = 'block'; // æ˜¾ç¤ºä¸‹è½½åŒºåŸŸ
            showAlert('Pearce å›¾è¡¨ç”ŸæˆæˆåŠŸï¼', 'success');
        }

        // CIPW æ ‡å‡†çŸ¿ç‰©è®¡ç®—
        function generateCIPWCalculation() {
            const requiredCols = ['SiO2', 'TiO2', 'Al2O3', 'Fe2O3', 'FeO', 'MnO', 'MgO', 'CaO', 'Na2O', 'K2O', 'P2O5'];
            const missingCols = requiredCols.filter(col => !globalData[0].hasOwnProperty(col));
            
            if (missingCols.length > 0) {
                // å°è¯•ä¼°ç®—ç¼ºå°‘çš„åˆ—
                globalData.forEach(row => {
                    missingCols.forEach(col => {
                        if (col === 'Fe2O3' && row['FeO']) {
                            row['Fe2O3'] = parseFloat(row['FeO']) * 0.15;
                        } else if (col === 'FeO' && row['Fe2O3']) {
                            row['FeO'] = parseFloat(row['Fe2O3']) * 0.9;
                        } else {
                            row[col] = 0.1;
                        }
                    });
                });
            }

            cipwResultData = [];

            // è®¡ç®— CIPW æ ‡å‡†çŸ¿ç‰©
            globalData.forEach((row, i) => {
                // è½¬æ¢ä¸ºåˆ†å­æ¯”ä¾‹
                const mol = {
                    SiO2: parseFloat(row.SiO2) / 60.08,
                    Al2O3: parseFloat(row.Al2O3) / 101.96,
                    Fe2O3: parseFloat(row.Fe2O3) / 159.69,
                    FeO: parseFloat(row.FeO) / 71.85,
                    MgO: parseFloat(row.MgO) / 40.30,
                    CaO: parseFloat(row.CaO) / 56.08,
                    Na2O: parseFloat(row.Na2O) / 61.98,
                    K2O: parseFloat(row.K2O) / 94.20,
                    TiO2: parseFloat(row.TiO2) / 79.87,
                    P2O5: parseFloat(row.P2O5) / 141.94,
                    MnO: parseFloat(row.MnO) / 70.94
                };

                // ç®€åŒ–çš„ CIPW è®¡ç®—
                const result = {
                    'Quartz': Math.max(0, mol.SiO2 - 2*mol.Na2O - 2*mol.K2O - mol.CaO - mol.MgO - mol.FeO - 2*mol.Fe2O3) * 60.08,
                    'Orthoclase': mol.K2O * 278.33,
                    'Albite': mol.Na2O * 262.22,
                    'Anorthite': Math.max(0, mol.Al2O3 - mol.Na2O - mol.K2O) * 278.21,
                    'Diopside': Math.min(mol.CaO - Math.max(0, mol.Al2O3 - mol.Na2O - mol.K2O), mol.MgO) * 216.55,
                    'Hypersthene': Math.max(0, mol.MgO - Math.min(mol.CaO - Math.max(0, mol.Al2O3 - mol.Na2O - mol.K2O), mol.MgO)) * 132.15,
                    'Magnetite': mol.Fe2O3 * 231.54,
                    'Ilmenite': mol.TiO2 * 151.73,
                    'Apatite': mol.P2O5 / 3 * 10 * 502.31
                };

                // æ ‡å‡†åŒ–åˆ° 100%
                const total = Object.values(result).reduce((sum, val) => sum + val, 0);
                Object.keys(result).forEach(key => {
                    result[key] = (result[key] / total) * 100;
                });

                cipwResultData.push(result);
            });

            // æ˜¾ç¤ºç»“æœè¡¨æ ¼
            displayCIPWResults();
            showAlert('CIPW æ ‡å‡†çŸ¿ç‰©è®¡ç®—å®Œæˆï¼', 'success');
        }

        function displayCIPWResults() {
            if (!cipwResultData || cipwResultData.length === 0) return;

            const minerals = Object.keys(cipwResultData[0]);
            let html = '<div class="table-wrapper"><table><thead><tr><th>æ ·å“</th>';
            minerals.forEach(mineral => {
                const shortMineral = mineral.length > 10 ? mineral.substring(0, 10) + '...' : mineral;
                html += `<th title="${mineral}">${shortMineral}</th>`;
            });
            html += '</tr></thead><tbody>';

            cipwResultData.forEach((result, i) => {
                html += `<tr><td>æ ·å“ ${i + 1}</td>`;
                minerals.forEach(mineral => {
                    const value = result[mineral].toFixed(2);
                    html += `<td title="${mineral}: ${value}%">${value}</td>`;
                });
                html += '</tr>';
            });

            html += '</tbody></table></div>';
            html += '<p style="font-size: 11px; color: #666; margin-top: 10px;">æ•°å€¼ä¸ºé‡é‡ç™¾åˆ†æ¯” (wt%)</p>';
            
            document.getElementById('cipwTable').innerHTML = html;
            document.getElementById('cipwResults').style.display = 'block';
        }

        // QAPF å›¾è¡¨ç”Ÿæˆ
        function generateQAPFPlot() {
            if (!cipwResultData || cipwResultData.length === 0) {
                showAlert('è¯·å…ˆè®¡ç®— CIPW æ ‡å‡†çŸ¿ç‰©ï¼', 'error');
                return;
            }

            // ä¸‰è§’åæ ‡è½¬æ¢
            function triToBin(q, a, p) {
                const total = q + a + p;
                if (total === 0) return [0.5, 0.5];
                
                const x = 0.5 + (a - p) / (2 * total);
                const y = (Math.sqrt(3) / 2) * (q / total);
                return [x, y];
            }

            const traces = [];

            // ç»˜åˆ¶ä¸‰è§’å½¢è¾¹ç•Œ
            const triangleBoundary = {
                x: [0, 1, 0.5, 0],
                y: [0, 0, Math.sqrt(3)/2, 0],
                mode: 'lines',
                type: 'scatter',
                line: { color: 'black', width: 2 },
                name: 'è¾¹ç•Œ',
                showlegend: false
            };
            traces.push(triangleBoundary);

            // ç»˜åˆ¶æ•°æ®ç‚¹
            const colorMapping = getColorMapping();
            const classificationCol = getClassificationColumn();
            
            if (classificationCol) {
                // æœ‰åˆ†ç±»åˆ—ï¼ŒæŒ‰åˆ†ç±»ç»˜åˆ¶
                const groups = {};
                cipwResultData.forEach((result, i) => {
                    const groupValue = globalData[i] && globalData[i][classificationCol] ? globalData[i][classificationCol] : 'Unknown';
                    if (!groups[groupValue]) {
                        groups[groupValue] = [];
                    }
                    groups[groupValue].push({ result, index: i });
                });
                
                Object.keys(groups).forEach((groupName) => {
                    const groupData = groups[groupName];
                    const color = colorMapping.legendItems.find(item => item.label === groupName)?.color || '#1f77b4';
                    
                    const x_vals = [];
                    const y_vals = [];
                    const texts = [];
                    
                    groupData.forEach(({ result, index }) => {
                        const q = Math.max(0, result.Quartz);
                        const a = Math.max(0, result.Orthoclase);
                        const p = Math.max(0, result.Albite + result.Anorthite);
                        
                        if (q + a + p > 0) {
                            const [x, y] = triToBin(q, a, p);
                            x_vals.push(x);
                            y_vals.push(y);
                            texts.push(`S${index + 1}`);
                        }
                    });
                    
                    if (x_vals.length > 0) {
                        traces.push({
                            x: x_vals,
                            y: y_vals,
                            mode: 'markers+text',
                            type: 'scatter',
                            name: groupName,
                            text: texts,
                            textposition: 'top center',
                            marker: { size: 10, color: color, opacity: 0.8 }
                        });
                    }
                });
            } else {
                // æ²¡æœ‰åˆ†ç±»åˆ—ï¼ŒæŒ‰æ ·å“ç¼–å·ç»˜åˆ¶
                cipwResultData.forEach((result, i) => {
                    const q = Math.max(0, result.Quartz);
                    const a = Math.max(0, result.Orthoclase);
                    const p = Math.max(0, result.Albite + result.Anorthite);
                    
                    if (q + a + p > 0) {
                        const [x, y] = triToBin(q, a, p);
                        
                        traces.push({
                            x: [x], 
                            y: [y],
                            mode: 'markers+text',
                            type: 'scatter',
                            name: colorMapping.labels[i] || `æ ·å“ ${i + 1}`,
                            text: [`S${i + 1}`],
                            textposition: 'top center',
                            marker: { 
                                size: 10, 
                                color: colorMapping.colors[i] || '#1f77b4', 
                                opacity: 0.8 
                            }
                        });
                    }
                });
            }

            const layout = {
                title: 'QAPF æ·±æˆå²©åˆ†ç±»å›¾',
                width: 800,
                height: 700,
                xaxis: { 
                    title: '', 
                    showgrid: false, 
                    showticklabels: false, 
                    range: [-0.1, 1.1],
                    fixedrange: true
                },
                yaxis: { 
                    title: '', 
                    showgrid: false, 
                    showticklabels: false, 
                    range: [-0.1, 1],
                    scaleanchor: 'x',
                    fixedrange: true
                },
                annotations: [
                    {x: 0.5, y: Math.sqrt(3)/2 + 0.05, text: 'Q (çŸ³è‹±)', showarrow: false, font: {size: 14, color: 'black'}},
                    {x: -0.05, y: -0.05, text: 'A (ç¢Ÿé•¿çŸ³)', showarrow: false, font: {size: 14, color: 'black'}},
                    {x: 1.05, y: -0.05, text: 'P (æ–œé•¿çŸ³)', showarrow: false, font: {size: 14, color: 'black'}}
                ],
                showlegend: true
            };

            Plotly.newPlot('plotDiv', traces, layout);
            document.getElementById('plotContainer').style.display = 'block';
            document.getElementById('downloadSection').style.display = 'block'; // æ˜¾ç¤ºä¸‹è½½åŒºåŸŸ
            showAlert('QAPF å›¾è¡¨ç”ŸæˆæˆåŠŸï¼', 'success');
        }

        // ä¸‹è½½å›¾è¡¨å‡½æ•° - æ”¯æŒ PNG, SVG, PDF æ ¼å¼ï¼Œç¡®ä¿å¯¼å‡ºæ¯”ä¾‹æ­£ç¡®
        function downloadPlot(format = 'png') {
            const plotDiv = document.getElementById('plotDiv');
            if (!plotDiv || !plotDiv.data || plotDiv.data.length === 0) {
                showAlert('æ²¡æœ‰å¯ä¸‹è½½çš„å›¾è¡¨', 'error');
                return;
            }

            // è·å–å½“å‰å›¾è¡¨ç±»å‹ä»¥è®¾ç½®åˆé€‚çš„æ–‡ä»¶å
            const plotType = document.getElementById('plotType').value || 'plot';
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '_');
            const filename = `${plotType}_geochemical_${timestamp}`;

            // æ ¹æ®å›¾è¡¨ç±»å‹è®¾ç½®å¯¼å‡ºå°ºå¯¸ï¼Œç¡®ä¿å­å›¾æ¯”ä¾‹æ­£ç¡®
            let exportWidth, exportHeight;
            if (plotType === 'harker') {
                // Harkerå›¾éœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œç¡®ä¿æ¯ä¸ªå­å›¾æ˜¯æ­£æ–¹å½¢
                exportWidth = 1200;  // å®½åº¦
                exportHeight = 1600; // é«˜åº¦ï¼Œä¿æŒ2:1æ¯”ä¾‹ï¼Œç¡®ä¿å­å›¾æ˜¯æ­£æ–¹å½¢
            } else {
                // å…¶ä»–å›¾è¡¨ä½¿ç”¨æ ‡å‡†å°ºå¯¸
                exportWidth = 1200;
                exportHeight = 800;
            }

            try {
                if (format === 'svg') {
                    // SVG ä¸‹è½½
                    Plotly.downloadImage(plotDiv, {
                        format: 'svg',
                        width: exportWidth,
                        height: exportHeight,
                        filename: filename
                    }).then(() => {
                        showAlert('SVG å›¾è¡¨ä¸‹è½½å®Œæˆï¼', 'success');
                    }).catch(error => {
                        console.error('SVG download error:', error);
                        showAlert('SVG ä¸‹è½½å¤±è´¥ï¼š' + error.message, 'error');
                    });
                } else if (format === 'pdf') {
                    // PDF ä¸‹è½½
                    Plotly.downloadImage(plotDiv, {
                        format: 'pdf',
                        width: exportWidth,
                        height: exportHeight,
                        filename: filename
                    }).then(() => {
                        showAlert('PDF å›¾è¡¨ä¸‹è½½å®Œæˆï¼', 'success');
                    }).catch(error => {
                        console.error('PDF download error:', error);
                        showAlert('PDF ä¸‹è½½å¤±è´¥ï¼š' + error.message, 'error');
                    });
                } else {
                    // PNG ä¸‹è½½ï¼ˆé»˜è®¤ï¼‰
                    Plotly.downloadImage(plotDiv, {
                        format: 'png',
                        width: exportWidth,
                        height: exportHeight,
                        filename: filename
                    }).then(() => {
                        showAlert('PNG å›¾è¡¨ä¸‹è½½å®Œæˆï¼', 'success');
                    }).catch(error => {
                        console.error('PNG download error:', error);
                        showAlert('PNG ä¸‹è½½å¤±è´¥ï¼š' + error.message, 'error');
                    });
                }
            } catch (error) {
                console.error('Download error:', error);
                showAlert(`${format.toUpperCase()} ä¸‹è½½å¤±è´¥ï¼š` + error.message, 'error');
            }
        }
    </script>
</body>
</html>